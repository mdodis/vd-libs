<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>vd_fw.h</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
<link rel="stylesheet" href="/style.css">
</head>
<body class="d-flex flex-column min-vh-100" data-bs-spy="scroll" data-bs-target="#toc" data-bs-offset="50" tabindex="0">
<!-- Begin Navbar -->
<nav id="mainnav" class="navbar sticky-top navbar-expand-md bg-body-tertiary">
<div class="container-fluid bg-body-tertiary">
<a class="navbar-brand" href="#">
<img    src="/assets/vd-logo-p@1x.png"
srcset="/assets/vd-logo-p@1x.png 1x, /assets/vd-logo-p@2x.png 2x"
alt="Brand"
width="64"
height="38.5">
</a>
<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" 
aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"></span>
</button>
<div class="collapse navbar-collapse" id="navbarNav">
<ul class="navbar-nav">
<li class="nav-item">
<a class="nav-link" aria-current="page" href="/index.html">Home</a>
</li>
<!-- Begin Files -->
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href="#" id="documentationDropdown" role="button"  data-bs-toggle="dropdown" aria-expanded="false">
Documentation
</a>
<ul class="dropdown-menu" aria-labelledby="documentationDropdown">
<li><a class="dropdown-item" href="/vd_fw.html">vd_fw.h</a></li>
</ul>
</li>
<!--   End Files -->
</ul>
<div class="search-container ms-auto me-auto me-sm-0">
<input type="search" id="searchbox" class="form-control" placeholder="Search" aria-label="Search" autocomplete="off" autofocus>
<ul id="search-results" class="list-group position-absolute" style="top:100%; z-index:1000; display:none;"></ul>
</div>
</div>
</div>
</nav>
<!--   End Navbar -->
<div class="container flex-grow-1">
<div class="row justify-content-center">
<div id="main-content" class="col-12 col-sm-12 flexijustify-midpoint col-md-8 col-lg-8 text-start mx-auto mx-lg-4">
<nav id="toc" data-toc class="toc-outline d-none midpoint-flex flexijustify-grow p-0 nav outline-section flex-column">
</nav>
<section class="L1 section" id="brief">
<h4>Brief</h4>
<hr>
<img src="/assets/fw/vd-fw-logo@1x.png" srcset="/assets/fw/vd-fw-logo@1x.png 1x, /assets/fw/vd-fw-logo@2x.png 2x" width="128" height="106.5" class="span-image" >
</img>
<p>
A <b>header-only</b> library that gets you a semi-customizable window and an OpenGL context, minimizing
dependencies and hiding the complexities of doing proper windowing on each platform.
</p>
<p>
It's written with performance in mind; though performance is not the main focus of it.
<b>Maintainability</b>, <b>support</b> for the defined feature set and <b>ease of use</b>
are the primary targets of this library.
</p>
<p>
This library can:
<ul>
<li>Open a window, handle input from keyboard/mouse/controller</li>
<li>Draw while resizing the window</li>
<li>Disable window decorations, but still be able to tile the window, customize the drag area, etc...</li>
<li>Load OpenGL (without using a loader library)</li>
<li>Set the window icon</li>
<li>All of that, with as minimal dependencies as possible (for example, you don't even need to link to or
have the development headers/libraries of X11/OpenGL, etc. on linux)</li>
</ul>
</p>
<p>
The main idea of this library is that you shouldn't need to think about installing CMake, or messing with your
build tool's link paths, <i>just</i> to be able to draw some stuff using the GPU.
It should be easy to just drop in
right inside of your project, and start developing, with full access to a relatively small source code size.
</p>
<p>
Additionally, this library:
<ul>
<li>Provides custom implementations of several math functions, like sinf</li>
<li>Doesn't use the standard C library (where possible)</li>
<li>Prodives convenience functions that can, for example, construct a perpsective projection matrix for OpenGL</li>
<li>Automatically sets up OpenGL debugging infrastructure</li>
</ul>
</p>
<p>
<b>Why should you use this library over, GLFW, SDL, SFML, ...?</b>
<br>
Those libraries solve a <b>much more</b> general problem than the one most developers have:
<ul>
<li>Create one or more windows</li>
<li>Handle child/parent window relationships</li>
<li>Provide aliases for common usermode operations (show file dialog, message box)</li>
<li>Support many more platforms, even ones that don't include a windowing system.</li>
<li>Support multiple graphics APIs for initialization.</li>
<li>Provide a high level drawing interface.</li>
<li>Provide a high level sound interface.</li>
<li>Allow for entirely customized windows.</li>
<li>And much more...</li>
</ul>
But in their attempt to be "generic" and "robust", they fail to provide a good and simple
interface that covers 90% of the use cases, and is implemented in the best way possible for
each platform.
</p>
<p>
One common example is that almost every popular windowing library on Windows does not allow
the developer to draw while resizing or moving the window.
This is an introcacy of the Win32 API (and actually the same is true for MacOS), and the
recommended way is not exactly obvious to a new developer, or one unfamiliar with the
platform.
<br>
</p>
<div class="alert alert-primary d-flex align-items-center" role="alert" >
Note that you don't need to use an OpenGL loader or include any OS specific OpenGL
libraries.
<br>
The library does the loading for you.
</div>
<p>
Here is all you need (and should need) to create a simple window.
<br>
By default it creates an OpenGL 3.3 core profile context:
</p>
<pre class="rounded copy"><code class="language-cpp">
#include "vd_fw.h"                                           // Include library
int main() {
    vd_fw_init(NULL);                                        // Initialize library
    while (vd_fw_running()) {                                // Check if the window is closed & gather events
        glClearColor(0.5f, 0.3f, 0.2f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        vd_fw_swap_buffers();                                // Swap buffers
    }
    return 0;
}

#define VD_FW_IMPL                                           // Include implementation code
#include "vd_fw.h"
    </code></pre>
<div id="fw-window-simple" class="rounded carousel slide">
<div class="carousel-inner">
<div class="carousel-item active">
<img class="img-fluid" src="/assets/fw/window-simple-win32.png">
</div>
<div class="carousel-item">
<img class="img-fluid" src="/assets/fw/window-simple-macos.png">
</div>
</div>
<button class="carousel-control-prev" type="button" data-bs-target="#fw-window-simple"        data-bs-slide="prev">
<span class="carousel-control-prev-icon" style="filter: invert(1) grayscale(100%) brightness(200%);"      aria-hidden="true"></span>
<span class="visually-hidden">Previous</span>
</button>
<button class="carousel-control-next" type="button" data-bs-target="#fw-window-simple"        data-bs-slide="next">
<span class="carousel-control-next-icon" style="filter: invert(1) grayscale(100%) brightness(200%);"      aria-hidden="true"></span>
<span class="visually-hidden">Next</span>
</button>
</div>
<div class="d-flex justify-content-end" >
<button type="button" class="btn ms-2 btn-outline-success" onclick="window.print();" >
PDF
</button>
<a type="button" class="btn ms-2 btn-outline-success" href="https://raw.githubusercontent.com/mdodis/vd-libs/main/vd_fw.h" >
Download
</a>
</div>
<br>
</section>
<section class="L1 section" id="linking-and-dependencies">
<h4>Linking & Dependencies</h4>
<hr>
<p>
This library is distributed as a single, header-only file, thus the following instructions
are meant to be considered for your final application/dynamic library.
<br> <br>
In general, I make use of the up-to-date platform specific APIs, that should be available
with every distribution of said platform's development environment.
<br> <br>
Some preprocessor directives to set depending on your needs:
</p>
<table class="table" >
<tr >
<th scope="col" >
Option 
</th>
<th scope="col" >
Description 
</th>
</tr>
<tbody >
<tr >
<td >
<code>VD_FW_VERSION_MAJOR</code>
</td>
<td >
Major version number of the library
</td>
</tr>
<tr >
<td >
<code>VD_FW_VERSION_MINOR</code>
</td>
<td >
Minor version number of the library
</td>
</tr>
<tr >
<td >
<code>VD_FW_VERSION_PATCH</code>
</td>
<td >
Patch version number of the library
</td>
</tr>
<tr >
<td >
<code>VD_FW_VERSION</code>
</td>
<td >
Combined version (major, minor, patch) number of the library
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_STATIC</code>
</td>
<td >
Set to use this library statically.
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_API // (static, extern, ...dllexport)</code>
</td>
<td >
Set to change the function signature (useful for precompiling the library).
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_INL
</td>
<td >
Set to change the function signature (useful for precompiling the library).
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_NO_CRT</code>
</td>
<td >
Options:
<ul>
<li>Set to '1' to disable including C standard library</li>
<li>Set to '0' to enable including C standard library</li>
</ul>
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_SIN</code>
</td>
<td >
Can be predefined to your implementation of sinf.
Options:
<ul>
<li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>sinf</code></li>
<li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_sin (custom implementation).</li>
</ul>
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_COS</code>
</td>
<td >
Can be predefined to your implementation of cosf.
Options:
<ul>
<li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>cosf</code></li>
<li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_cos (custom implementation).</li>
</ul>
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_TAN</code>
</td>
<td >
Can be predefined to your implementation of tanf.
Options:
<ul>
<li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>tanf</code></li>
<li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_tan (custom implementation).</li>
</ul>
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_SQRT</code>
</td>
<td >
Can be predefined to your implementation of sqrtf.
Options:
<ul>
<li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>sqrtf</code></li>
<li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_sqrt (custom implementation).</li>
</ul>
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_MEMCPY</code>
</td>
<td >
Can be predefined to your implementation of memcpy.
Options:
<ul>
<li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>memcpy</code></li>
<li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_memcpy (custom implementation).</li>
</ul>
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_MEMSET</code>
</td>
<td >
Can be predefined to your implementation of memset.
Options:
<ul>
<li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>memset</code></li>
<li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_memset (custom implementation).</li>
</ul>
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_PREFER_DISCRETE_GPU</code><br>
<code>// Or</code><br>
<code>#define VD_FW_PREFER_INTEGRATED_GPU</code><br>
</td>
<td >
Change the preferred GPU for the OpenGL context.
</td>
</tr>
<tr >
<td >
<b>Win32 Specific</b>
</td>
<td >
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_WIN32_SUBSYSTEM</code><br>
<code>// Can be one of the following:</code><br>
<code>// VD_FW_WIN32_SUBSYSTEM_CONSOLE</code><br>
<code>// VD_FW_WIN32_SUBSYSTEM_WINDOWS</code>
</td>
<td >
Change the <a href="https://learn.microsoft.com/en-us/cpp/build/reference/subsystem-specify-subsystem?view=msvc-170">Subsystem</a>
(Windows only).
</td>
</tr>
<tr >
<td >
<code>#define VD_FW_WIN32_NO_LINKER_COMMENTS</code>
</td>
<td >
Disable automatic linker comments (Windows only).
</td>
</tr>
</tbody>
</table>
<section class="L2 section" id="windows">
<h4>Windows</h4>
<p>
With MSVC you don't really need to link anything since linker directives in the
translation unit that includes vd_fw.h are defined, so that the appropriate libraries
and subsystem are used. Additionally, several core libraries are <b>dynamically</b> loaded in vd_fw_init.
The only library required during compilation is <code>kernel32.lib</code>. For reference, here are the
libraries this library tries to load during vd_fw_init:
<ol class="list-group">
<li class="list-group-item">User32</li>
<li class="list-group-item">OpenGL32</li>
<li class="list-group-item">Dwmapi</li>
<li class="list-group-item">Gdi32</li>
<li class="list-group-item">uxtheme</li>
<li class="list-group-item">shell32</li>
<li class="list-group-item">winmm</li>
</ol>
<br>
</p>
<p>
This library tries as much as possible to reduce the amount of code brought in with the (notoriously large)
Windows includes. This is done by manually declaring enumerations, preprocessor macros, function signatures,
and structures right inside the implementation part of the library. This looks like this:
</p>
<pre class="rounded copy"><code class="language-cpp">
typedef struct VdFwtagRGBQUAD {
    VdFwBYTE    rgbBlue;
    VdFwBYTE    rgbGreen;
    VdFwBYTE    rgbRed;
    VdFwBYTE    rgbReserved;
} VdFwRGBQUAD;

typedef struct VdFwtagBITMAPINFO {
    VdFwBITMAPINFOHEADER    bmiHeader;
    VdFwRGBQUAD             bmiColors[1];
} VdFwBITMAPINFO, * VdFwLPBITMAPINFO, * VdFwPBITMAPINFO;

#define VD_FW_PROC_ChoosePixelFormat(name) int name(VdFwHDC hdc, const VdFwPIXELFORMATDESCRIPTOR *ppfd)
typedef VD_FW_PROC_ChoosePixelFormat(VdFwProcChoosePixelFormat);
static VdFwProcChoosePixelFormat *VdFwChoosePixelFormat;

#define VD_FW_PROC_CreateBitmap(name) VdFwHBITMAP name(int nWidth, int nHeight, VdFwUINT nPlanes, VdFwUINT nBitCount, const void* lpBits)
typedef VD_FW_PROC_CreateBitmap(VdFwProcCreateBitmap);
static VdFwProcCreateBitmap *VdFwCreateBitmap;
        </code></pre>
<p>
The relevant functions are then loaded when you call vd_fw_init:
</p>
<pre class="rounded copy"><code class="language-cpp">
HMODULE m             = LoadLibraryA("Gdi32.dll");
VdFwChoosePixelFormat     =     (VdFwProcChoosePixelFormat*)GetProcAddress(m, "ChoosePixelFormat");
VdFwCreateBitmap          =          (VdFwProcCreateBitmap*)GetProcAddress(m, "CreateBitmap");
        </code></pre>
<p>
Note that all platform specific functions/typedefs/structs are prefixed with 'VdFw' or 'VD_FW_' so as not to
induce collisions in cases where you need to include Windows functionality yourself.
</p>
<p>
To set the subsystem of the application: 
<ul>
<li> Windows: <code>#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_WINDOWS</code> </li>
<li> Console: <code>#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_CONSOLE</code> </li>
</ul>
</p>
<p>
If you're on the Windows subsystem, but would still like a console for debugging purposes, this
can be done by setting <code>VdFwInitInfo::gl_options::debug_on = 1</code> when calling
<code>vd_fw_init</code>.
<br>
This will allocate a console and set-up the relevant gl debug callback for you.
</p>
<p>
It's highly recommended to <code>#define VD_FW_NO_CRT 1</code> so that the CRT is removed
when linking. This can reduce the final executable size by a factor of 10 (for small applications).
</p>
<p>
If you'd like to define options by yourself,
<code>#define VD_FW_WIN32_NO_LINKER_COMMENTS</code> before including the implementation.
</p>
</section>
<br>
<section class="L2 section" id="macos">
<h4>MacOS</h4>
<p>
For MacOS, it's a bit different. with clang, you must link several frameworks (via 
<code>-framework framework_name</code>). Additionally, <code>-x objective-c</code> must be used since the
Mac APIs use Objective-C.
<ol class="list-group">
<li class="list-group-item">pthread (compiler flag)</li>
<li class="list-group-item">Cocoa</li>
<li class="list-group-item">Metal</li>
<li class="list-group-item">QuartzCore</li>
<li class="list-group-item">CoreGraphics</li>
<li class="list-group-item">IOSurface</li>
<li class="list-group-item">IOKit</li>
<li class="list-group-item">Foundation</li>
<li class="list-group-item">OpenGL</li>
</ol>
</p>
<p>
OpenGL on MacOS is deprecated, and including it will throw a ton of warnings about
each function. Its maximum supported version of OpenGL is <b>4.1</b>.
</p>
<p>
To disable those warnings, you can create the following header file and use it
before and after including vd_fw.h:
</p>
<pre class="rounded copy"><code class="language-cpp">
#ifndef DISABLE_CLANG_DEPRECATIONS_H1
#define DISABLE_CLANG_DEPRECATIONS_H1
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#endif // defined(__clang__)
#else
#if defined(__clang__)
#pragma clang diagnostic pop
#endif // defined(__clang__)
#endif // DISABLE_CLANG_DEPRECATIONS_H1
        </code></pre>
</section>
<br>
</section>
<section class="L1 section" id="support">
<h4>Support</h4>
<hr>
<pre class="rounded copy"><code class="language-txt">
zlib License

(C) Copyright 2025-2026 Michael Dodis (michaeldodisgr@gmail.com)
 This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
        </code></pre>
<p>
As stated in the license, no warranty or guarantee is provided by the use of this library.
</p>
<p>
That being said, I will look at issues when I have the time, and/or if they are important to the core
principles of this library.
</p>
<p>
<a class="link-opacity-100" href="https://github.com/mdodis/vd-libs/issues/new">Submit issues here</a>
</p>
<section class="L2 section" id="platforms">
<h4>Platforms</h4>
<p>
Due to platform limitations, platform-specific APIs and frameworks, vd_fw.h will
never have support for some platforms. One example is Android, where Java is required.
</p>
<p>
Though, I'm still thinking about how this can be done easily, so I will leave the possibility
open.
</p>
<table class="table" >
<tr >
<th scope="col" >
Platform
</th>
<th scope="col" >
Supported
</th>
</tr>
<tbody >
<tr >
<td >
Windows
</td>
<td class="table-success" >
Yes
</td>
</tr>
<tr >
<td >
MacOS
</td>
<td class="table-warning" >
In Progress
</td>
</tr>
<tr >
<td >
Linux (X11)
</td>
<td class="table-warning" >
In Progress
</td>
</tr>
<tr >
<td >
Linux (Wayland)
</td>
<td >
Planned
</td>
</tr>
<tr >
<td >
iOS
</td>
<td >
Planned
</td>
</tr>
<tr >
<td >
Android
</td>
<td >
Not Planned
</td>
</tr>
<tr >
<td >
Web
</td>
<td >
Not Planned
</td>
</tr>
</tbody>
</table>
</section>
<br>
<section class="L2 section" id="revisions">
<h4>Revisions</h4>
<div class="list-group">
<a class="list-group-item revision-planned">
<div class="d-flex w-100 justify-content-between">
<h5 class="mb-1">1.1.0</h5>
<small class="text-body-secondary">xx/xx/xxxx</small>
</div>
<p class="mb-1">
<ul>
<li>Audio Buffer</li>
<li>Distribution</li>
<li>GL Extensions</li>
</ul>
</p>
</a>
<a class="list-group-item">
<div class="d-flex w-100 justify-content-between">
<h5 class="mb-1">1.0.0</h5>
<small class="text-body-secondary">xx/xx/xxxx</small>
</div>
<p class="mb-1">
Initial Release:
<ul>
<li>Win32 support</li>
<li>MacOS support</li>
</ul>
</p>
</a>
</div>
</section>
<br>
<section class="L2 section" id="attributions">
<h4>Attributions</h4>
<ul>
<li>
<a href="https://github.com/CookedNick">CookedNick</a><br>
For the render thread with Win32 example in jai
</li>
<li>
<a href="https://github.com/idrassi/">idrassi</a><br>
For the ported jai code for Win32 example
</li>
<li>
<a href="https://github.com/melak47/BorderlessWindow">melak47</a><br>
For the borderless window with Win32 example
</li>
<li>
<a href="https://github.com/TheoBendixson">TheoBendixson</a><br>
For his Handmade Mac platform layer
</li>
</ul>
</section>
<br>
</section>
<section class="L1 section" id="tutorials">
<h4>Tutorials</h4>
<hr>
<p>
A collection of tutorials for how to use the library.
</p>
<p>
These do not show proper code, nor do they show correct OpenGL API usage, but they show various
features of vd_fw.h
</p>
<p>
We will start by creating a simple window, and continue with:
<ul>
<li>Making it borderless</li>
<li>Drawing a rectangle</li>
<li>Setting the drag area</li>
<li>Drawing some 3D geometry</li>
<li>Handling input in a user-friendly way</li>
</ul>
You can safely read each tutorial on its own, or in order. It will guide you through
almost all of the parts of the API
</p>
<p>
Additionally, several samples are available <a href="https://github.com/mdodis/vd-libs/tree/main/samples">here</a>,
which map to several parts of the tutorial.
</p>
<p>
This tutorial is written in C, but you can safely use C++ with it
</p>
<section class="L2 section" id="main-loop">
<h4>Main Loop</h4>
<p>
Let's look at the main loop.
</p>
<pre class="rounded copy"><code class="language-cpp">
#define VD_FW_NO_CRT 0                                       // Disable CRT, this is highly recommended,
                                                             // if you know what you're doing.
#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_WINDOWS  // Disable console (Windows)
#include "vd_fw.h"

int main(int argc, char const *argv[])
{
    vd_fw_init(NULL);                                        // Initialize library
    vd_fw_set_vsync_on(1);                                   // Enable VSYNC

    while (vd_fw_running()) {                                // Check if user closed the window

        int w, h;
        vd_fw_get_size(&w, &h);                              // Get window size, in pixels.

        glViewport(0, 0, w, h);                              // Setup viewport
        glClearColor(0.5f, 0.3f, 0.2f, 1.0f);                // Select clear color
        glClear(GL_COLOR_BUFFER_BIT);                        // Clear

        vd_fw_swap_buffers();                                // Swap buffers
    }

    return 0;
}

#define VD_FW_IMPL                                           // Include implementation
#include "vd_fw.h"

        </code></pre>
<p>
This will create a window, that can be moved and resized.
</p>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-main-loop.gif" >
</img>
</section>
<br>
<section class="L2 section" id="choose-opengl-version">
<h4>Choose OpenGL Version</h4>
<p>
To specify the OpenGL version, create a <code>VdFwInitInfo</code> struct, populate the
<code>VdFwInitInfo::gl::version</code> member, and pass it to <code>vd_fw_init</code>.
</p>
<pre class="rounded copy"><code class="language-cpp">
VdFwInitInfo init_info = {};
init_info.gl.version = VD_FW_GL_VERSION_4_5; // Set OpenGL Version
vd_fw_init(&init_info);
        </code></pre>
<p>
For reference, here's all of the possible versions:
</p>
<pre class="rounded copy"><code class="language-cpp">
typedef enum {
    VD_FW_GL_VERSION_BASIC = 0,
    VD_FW_GL_VERSION_1_0   = 1,
    VD_FW_GL_VERSION_1_2   = 12,
    VD_FW_GL_VERSION_1_3   = 13,
    VD_FW_GL_VERSION_1_4   = 14,
    VD_FW_GL_VERSION_1_5   = 15,
    VD_FW_GL_VERSION_2_0   = 20,
    VD_FW_GL_VERSION_2_1   = 21,
    VD_FW_GL_VERSION_3_0   = 30,
    VD_FW_GL_VERSION_3_1   = 31,
    VD_FW_GL_VERSION_3_2   = 32,
    VD_FW_GL_VERSION_3_3   = 33,
    VD_FW_GL_VERSION_4_0   = 40,
    VD_FW_GL_VERSION_4_1   = 41,
    VD_FW_GL_VERSION_4_2   = 42,
    VD_FW_GL_VERSION_4_3   = 43,
    VD_FW_GL_VERSION_4_4   = 44,
    VD_FW_GL_VERSION_4_5   = 45,
    VD_FW_GL_VERSION_4_6   = 46,
} VdFwGlVersion;
        </code></pre>
</section>
<br>
<section class="L2 section" id="create-a-borderless-window">
<h4>Create a Borderless Window</h4>
<p>
To create a borderless window, create a <code>VdFwInitInfo</code> struct, set
<code>VdFwInitInfo::window_options::borderless</code> to 1, and pass it to <code>vd_fw_init</code>.
</p>
<pre class="rounded copy"><code class="language-cpp">
VdFwInitInfo init_info = {};
init_info.window_options.borderless = 1;
vd_fw_init(&init_info);
        </code></pre>
<p>
This will create a borderless window, that can be moved (by dragging any part of the window), and resized.
</p>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-borderless.gif" >
</img>
</section>
<br>
<section class="L2 section" id="create-a-shader-program">
<h4>Create a Shader Program</h4>
<p>
Let's create a simple 2D rectangle application.
</p>
<p>
We'll create some in-source shaders, and compile them, as we would in any OpenGL application.
If you'd like to follow along, here are the shaders we'll be using:
</p>
<pre class="rounded copy"><code class="language-cpp">
#define VERTEX_SOURCE \
"#version 330 core                                                                                                 \n" \
"layout (location = 0) in vec2 aPos;                                                                               \n" \
"                                                                                                                  \n" \
"uniform vec2 rect_off;                                                                                            \n" \
"uniform vec2 rect_size;                                                                                           \n" \
"uniform mat4 projection;                                                                                          \n" \
"                                                                                                                  \n" \
"                                                                                                                  \n" \
"void main()                                                                                                       \n" \
"{                                                                                                                 \n" \
"    gl_Position = projection * vec4(aPos * rect_size + rect_off, 0.0, 1.0f);                                      \n" \
"}                                                                                                                 \n" \

#define FRAGMENT_SOURCE \
"#version 330 core                                                                                                 \n" \
"out vec4 FragColor;                                                                                               \n" \
"                                                                                                                  \n" \
"uniform vec4 rect_color;                                                                                          \n" \
"                                                                                                                  \n" \
"void main()                                                                                                       \n" \
"{                                                                                                                 \n" \
"    FragColor = rect_color;                                                                                       \n" \
"}                                                                                                                 \n" \
        </code></pre>
<p>
And the typical OpenGL shader compilation code:
</p>
<pre class="rounded copy"><code class="language-cpp">
const char *vertex_shader_source = VERTEX_SOURCE;
const char *fragment_shader_source = FRAGMENT_SOURCE;

// Compile shaders
GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vertex_shader, 1, &vertex_shader_source, 0);
glCompileShader(vertex_shader);

GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragment_shader, 1, &fragment_shader_source, 0);
glCompileShader(fragment_shader);

GLuint program = glCreateProgram();
glAttachShader(program, vertex_shader);
glAttachShader(program, fragment_shader);
glLinkProgram(program);
        </code></pre>
<p>
In most tutorials, you'll be prompted to do error checking by doing <code>glGetShaderiv</code>,
then <code>glGetShaderInfoLog</code> and printing it out...
</p>
<p>
This library provides a convenience function (and more) to do that, and will also log the errors:
</p>
<pre class="rounded copy"><code class="language-cpp">
GLuint vertex_shader   = vd_fw_compile_shader(GL_VERTEX_SHADER,   VERTEX_SOURCE);
GLuint fragment_shader = vd_fw_compile_shader(GL_FRAGMENT_SHADER, FRAGMENT_SOURCE);
        </code></pre>
<p>
For error logging, make sure to set <code>VdFwInitInfo::gl::debug_on</code> to 1 when initializing the library.
Here's the <code>vd_fw_init</code> call we'll be using for the rest of these tutorials:
</p>
<pre class="rounded copy"><code class="language-cpp">
vd_fw_init(& (VdFwInitInfo) {
    .gl = {
        .version = VD_FW_GL_VERSION_3_3,
        .debug_on = 1,
    },
    .window_options = {
        .borderless = 1,
    }
});
        </code></pre>
</section>
<br>
<section class="L2 section" id="draw-a-rectangle">
<h4>Draw a Rectangle</h4>
<p>
Continuing from the previous section, we create a vertex buffer for a 2d rectangle:
</p>
<pre class="rounded copy"><code class="language-cpp">
float rect_vertices[] = {
     0.0f,  0.0f,
    +1.0f,  0.0f,
     0.0f, +1.0f,
    +1.0f, +1.0f
};

unsigned int VBO, VAO;
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);
glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(rect_vertices), rect_vertices, GL_STATIC_DRAW);
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
        </code></pre>
<p>
And now for drawing a rectangle.
</p>
<p>
We'll use orthographic projection. vd_fw.h provides a simple utility function to compute it:
<code>vd_fw_u_ortho</code>
</p>
<pre class="rounded copy"><code class="language-cpp">
glUseProgram(program);
glBindVertexArray(VAO);

{
    float projection[16];
    vd_fw_u_ortho(0.f, (float)w, (float)h, 0.f, -1.f, 1.f, projection);
    glUniformMatrix4fv(glGetUniformLocation(program, "projection"), 1, GL_FALSE, projection);
}
        </code></pre>
<p>
To test that the coordinate transformation is working, we'll map the top left of the rectangle
to the mouse. To get the mouse position & buttons, use <code>vd_fw_get_mouse_state</code> or
<code>vd_fw_get_mouse_statef</code>:
</p>
<pre class="rounded copy"><code class="language-cpp">
float mx, my;
vd_fw_get_mouse_statef(&mx, &my);

glUniform4f(glGetUniformLocation(program, "rect_color"), 1.f, 0.f, 0.f, 1.f);
glUniform2f(glGetUniformLocation(program, "rect_size"), 40.f, 40.f);
glUniform2f(glGetUniformLocation(program, "rect_off"), mx, my);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

glUseProgram(0);
glBindVertexArray(0);
        </code></pre>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-drawing-a-rectangle.gif" >
</img>
</section>
<br>
<section class="L2 section" id="set-the-drag-area">
<h4>Set the Drag Area</h4>
<p>
Let's draw a simple window frame using our rectangle "renderer":
</p>
<pre class="rounded copy"><code class="language-cpp">
glUniform4f(glGetUniformLocation(program, "rect_color"), 0.2f, 0.2f, 0.2f, 1.f);
glUniform2f(glGetUniformLocation(program, "rect_size"), (float)w, 30.f);
glUniform2f(glGetUniformLocation(program, "rect_off"), 0.f, 0.f);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
        </code></pre>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-frame.gif" >
</img>
<p>
In a borderless window, there is no specified non-client area. So to allow the user to drag the window
only from a specific place, we'll use <code>vd_fw_set_ncrects</code>.
</p>
<pre class="rounded copy"><code class="language-cpp">
int draggable_rect[4] = {
    0,  // left
    0,  // top
    w,  // right
    30, // bottom
};
vd_fw_set_ncrects(draggable_rect, 0, 0);
        </code></pre>
<p>
Et voila!
</p>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-drag-frame.gif" >
</img>
<p>
Now, for the 2 last parameters to <code>vd_fw_set_ncrects</code>:
<ul>
<li>count: Number of excluded rects</li>
<li>rects: Pointer to array of <code>count</code> rects</li>
</ul>
These allow you to set areas inside the drag area, that are not draggable.
</p>
<p>
Let's draw a red 'close' button in our title bar, and if the mouse is over it, darken it:
</p>
<pre class="rounded copy"><code class="language-cpp">
float button_color[4] = {1.0f, 0.0f, 0.0f, 1.0f};
int mouse_inside_close_button =
    (mx > ((float)w - 30.f)) &&
    (my > (0.f) && my < (30.f));

if (mouse_inside_close_button) {
    button_color[0] = 0.7f;    
    button_color[1] = 0.0f;    
    button_color[2] = 0.0f;    
    button_color[3] = 1.0f;    
}

glUniform4f(glGetUniformLocation(program, "rect_color"), button_color[0],
                                                         button_color[1],
                                                         button_color[2],
                                                         button_color[3]);
glUniform2f(glGetUniformLocation(program, "rect_size"), 30.f, 30.f);
glUniform2f(glGetUniformLocation(program, "rect_off"), (float)w - 30.f, 0.f);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
        </code></pre>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-button.gif" >
</img>
<p>
As you can see, we can still drag the window even if the mouse is on the button. <br>
</p>
<p>
To fix that, we have to update our call to <code>vd_fw_set_ncrects</code>:
</p>
<pre class="rounded copy"><code class="language-cpp">
int draggable_rect[4] = {
    0,  // left
    0,  // top
    w,  // right
    30, // bottom
};

int exclude_rects[1][4] = {
    {
        w - 30, // left
        0,      // top
        w,      // right
        30,     // bottom
    }
};
vd_fw_set_ncrects(draggable_rect, 1, exclude_rects);
        </code></pre>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-button-no-drag.gif" >
</img>
<p>
The code is straightforward; we exclude the exact position of our red button.
</p>
</section>
<br>
<section class="L2 section" id="draw-a-cube">
<h4>Draw a Cube</h4>
<p>
Let's render some 3D geometry.
For this, we'll need separate shaders; if you're following the tutorial in order, here they are:
</p>
<pre class="rounded copy"><code class="language-cpp">
#define VERTEX_SOURCE3D \
"#version 330 core                                        \n" \
"layout (location = 0) in vec3 aPos;                      \n" \
"layout (location = 1) in vec2 aTexCoord;                 \n" \
"                                                         \n" \
"out vec2 TexCoord;                                       \n" \
"                                                         \n" \
"uniform mat4 projection;                                 \n" \
"uniform mat4 view;                                       \n" \
"                                                         \n" \
"void main()                                              \n" \
"{                                                        \n" \
"    gl_Position = projection * view * vec4(aPos, 1.0f);  \n" \
"    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);     \n" \
"}                                                        \n" \

#define FRAGMENT_SOURCE3D \
"#version 330 core                                        \n" \
"out vec4 FragColor;                                      \n" \
"                                                         \n" \
"in vec2 TexCoord;                                        \n" \
"                                                         \n" \
"uniform sampler2D texture1;                              \n" \
"                                                         \n" \
"void main()                                              \n" \
"{                                                        \n" \
"    FragColor = texture(texture1, TexCoord);             \n" \
"}                                                        \n" \
        </code></pre>
<p>
We'll also create a 3d cube, and a checkerboard texture:
</p>
<pre class="rounded copy"><code class="language-cpp">
float vertices3d[] = {
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
};

unsigned int VBO3D, VAO3D;
glGenVertexArrays(1, &VAO3D);
glGenBuffers(1, &VBO3D);
glBindVertexArray(VAO3D);
glBindBuffer(GL_ARRAY_BUFFER, VBO3D);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices3d), vertices3d, GL_STATIC_DRAW);
// position attribute
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// texture coord attribute
glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);

unsigned int checkerboard[] = {
    0xFFFFFFFF, 0xFF000000,
    0xFF000000, 0xFFFFFFFF
};

GLuint texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 2, 2, 0, GL_RGBA, GL_UNSIGNED_BYTE, checkerboard);
glGenerateMipmap(GL_TEXTURE_2D);
        </code></pre>
<p>
Since we'll be rendering both 3D and 2D, we'll need to make sure GL_DEPTH_TEST is only
enabled for the 3D part of our rendering:
</p>
<pre class="rounded copy"><code class="language-cpp">
glDisable(GL_DEPTH_TEST);
glUseProgram(program);
glBindVertexArray(VAO);

float projection[16];
vd_fw_u_ortho(0.f, (float)w, (float)h, 0.f, -1.f, 1.f, projection);
glUniformMatrix4fv(glGetUniformLocation(program, "projection"), 1, GL_FALSE, projection);
// ... Rest of 2D rendering code

glEnable(GL_DEPTH_TEST);
// 3D rendering code
        </code></pre>
<p>
Before our main loop, we're also going to add some variables for the camera:
</p>
<pre class="rounded copy"><code class="language-cpp">
float camera_position[3] = {0.f, 0.f, -2.f};
float camera_yaw   = 0.f;
float camera_pitch = 30.f;
float deg2rad = 3.14159265359f / 180.f;
float camera_speed = 2.f;
        </code></pre>
<p>
Now for rendering the cube depending on camera position & rotation:
</p>
<pre class="rounded copy"><code class="language-cpp">
glEnable(GL_DEPTH_TEST);
float fw = (float)w;
float fh = (float)h;

// Compute forward vector
float camera_forward[3] = {
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_SIN(deg2rad * camera_yaw),
    VD_FW_SIN(deg2rad * camera_pitch),
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_COS(deg2rad * camera_yaw)
};

// Normalize forward vector
float camera_forward_len = VD_FW_SQRT(
    camera_forward[0] * camera_forward[0] +
    camera_forward[1] * camera_forward[1] +
    camera_forward[2] * camera_forward[2]);

camera_forward[0] = camera_forward[0] / camera_forward_len;
camera_forward[1] = camera_forward[1] / camera_forward_len;
camera_forward[2] = camera_forward[2] / camera_forward_len;

float camera_ref_up[3] = {0.f, 1.f, 0.f};

// Compute right vector by taking the cross product of foward x up
float camera_right[3] = {
    camera_forward[1] * camera_ref_up[2] - camera_forward[2] * camera_ref_up[1],
    camera_forward[2] * camera_ref_up[0] - camera_forward[0] * camera_ref_up[2],
    camera_forward[0] * camera_ref_up[1] - camera_forward[1] * camera_ref_up[0],
};

// Normalize right vector
float camera_right_len = VD_FW_SQRT(
    camera_right[0] * camera_right[0] +
    camera_right[1] * camera_right[1] +
    camera_right[2] * camera_right[2]);

camera_right[0] = camera_right[0] / camera_right_len;
camera_right[1] = camera_right[1] / camera_right_len;
camera_right[2] = camera_right[2] / camera_right_len;

glViewport(0, 0, w, h - 30);
glUseProgram(program3d);
glBindVertexArray(VAO3D);

float projection[16] = {0.f};
vd_fw_u_perspective(60.f, fw / fh, 0.1f, 100.0f, projection);

float view[16] = {0.f};
float ctar[3] = {
    camera_position[0] + camera_forward[0],
    camera_position[1] + camera_forward[1],
    camera_position[2] + camera_forward[2]};
float cup[3]  = {0.f, 1.f, 0.f};
vd_fw_u_lookat(camera_position, ctar, cup, view);

glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture);

glUseProgram(program3d);
glUniformMatrix4fv(glGetUniformLocation(program3d, "projection"), 1, GL_FALSE, projection);
glUniformMatrix4fv(glGetUniformLocation(program3d, "view"), 1, GL_FALSE, view);
glUniform1i(glGetUniformLocation(program3d, "texture1"), 0);

glBindVertexArray(VAO3D);

glDrawArrays(GL_TRIANGLES, 0, 36);
        </code></pre>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-rendering-cube.gif" >
</img>
<p>
And here we have a 3d cube! As you can see, I've already added the movement of the camera
for demonstration purposes, but we'll have a look at input in the next section.
</p>
</section>
<br>
<section class="L2 section" id="handle-input">
<h4>Handle Input</h4>
<p>
We've already seen some mouse state handling, but let's look at the main functions used for
input:
<ul>
<li><code>vd_fw_delta_s</code>, to get delta time since last frame</li>
<li><code>vd_fw_get_mouse_state</code>, to read the mouse state</li>
<li><code>vd_fw_get_mouse_delta</code>, to read how much the mouse moved since last frame</li>
<li><code>vd_fw_get_key_down</code>, to check if a key is currently down</li>
<li><code>vd_fw_get_key_pressed</code>, to check if a key was just pressed</li>
<li><code>vd_fw_set_mouse_locked</code>, to hide and confine the mouse to the window</li>
</ul>
</p>
<p>
So let's add some camera manipulation, we'll start by getting the delta time in seconds:
</p>
<pre class="rounded copy"><code class="language-cpp">
float ds = vd_fw_delta_s();
        </code></pre>
<p>
It's also common to lock the mouse and hide it, so let's do that as well at the start of the
application:
</p>
<pre class="rounded copy"><code class="language-cpp">
vd_fw_set_mouse_locked(1);
        </code></pre>
<p>
Here's also the snippet moving the camera:
</p>
<pre class="rounded copy"><code class="language-cpp">
// Get key states
float fwdir = (float)(vd_fw_get_key_down('W') - vd_fw_get_key_down('S'));
float rgdir = (float)(vd_fw_get_key_down('A') - vd_fw_get_key_down('D'));
float updir = (float)(vd_fw_get_key_down('Q') - vd_fw_get_key_down('E'));

// Compute overall move direction
float camera_move_dir[3] = {
    fwdir * camera_forward[0] + rgdir * camera_right[0] + updir * camera_ref_up[0],
    fwdir * camera_forward[1] + rgdir * camera_right[1] + updir * camera_ref_up[1],
    fwdir * camera_forward[2] + rgdir * camera_right[2] + updir * camera_ref_up[2],
};

// Normalize move direction, if it's length is not too small (i.e. we're not pressing any keys)
float camera_dir_lensq = 
    camera_move_dir[0] * camera_move_dir[0] +
    camera_move_dir[1] * camera_move_dir[1] +
    camera_move_dir[2] * camera_move_dir[2];

if (camera_dir_lensq > 0.0001f) {
    // Normalize move direction and apply it to the camera's position
    float camera_move_dir_len = VD_FW_SQRT(camera_dir_lensq);

    camera_move_dir[0] = camera_move_dir[0] / camera_move_dir_len;
    camera_move_dir[1] = camera_move_dir[1] / camera_move_dir_len;
    camera_move_dir[2] = camera_move_dir[2] / camera_move_dir_len;

    camera_position[0] += camera_move_dir[0] * camera_speed * ds;
    camera_position[1] += camera_move_dir[1] * camera_speed * ds;
    camera_position[2] += camera_move_dir[2] * camera_speed * ds;
}
        </code></pre>
<p>
Finally, inside of our rendering loop, we compute the camera's pitch and yaw based on the mouse delta:
</p>
<pre class="rounded copy"><code class="language-cpp">
if (vd_fw_get_mouse_locked()) {
    float mouse_delta_x, mouse_delta_y;
    vd_fw_get_mouse_delta(&mouse_delta_x, &mouse_delta_y);

    camera_yaw   += mouse_delta_x;
    camera_pitch -= mouse_delta_y;
};

if (camera_pitch < -89.9f) camera_pitch = -89.9f;
if (camera_pitch > +89.9f) camera_pitch = +89.9f;

if (camera_yaw > +360.f) camera_yaw -= 360.f;
if (camera_yaw < -360.f) camera_yaw += 360.f;

float camera_forward[3] = {
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_SIN(deg2rad * camera_yaw),
    // ..
        </code></pre>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-rendering-camera.gif" >
</img>
<p>
Okay, we can move the cube, but we can't really exit the application easily, since the mouse
is confined. Let's make 'Shift + F1' unlock the mouse:
</p>
<pre class="rounded copy"><code class="language-cpp">
if (vd_fw_get_key_pressed(VD_FW_KEY_F1) && vd_fw_get_key_down(VD_FW_KEY_LSHIFT)) {
    vd_fw_set_mouse_locked(!vd_fw_get_mouse_locked());
}
        </code></pre>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-rendering-cubeapp.gif" >
</img>
<p>
And we finally have a resizable, draggable window with our own custom button and cube.
</p>
</section>
<br>
<section class="L2 section" id="set-the-window-icon">
<h4>Set the Window Icon</h4>
<p>
To set the window icon, call:
</p>
<pre class="rounded copy"><code class="language-cpp">
// Image format must be in ARGB little-endian (i.e 0xAARRGGBB)
vd_fw_set_app_icon(pixels, width, height);
        </code></pre>
<p>
If you're following along with the tutorial, we will temporarily change the window to have
decorations, so that we can see the icon drawn by Windows in the caption:
</p>
<pre class="rounded copy"><code class="language-cpp">
vd_fw_init(& (VdFwInitInfo) {
    .gl = {
        .version = VD_FW_GL_VERSION_3_3,
        .debug_on = 0,
    },
    .window_options = {
        .borderless = 0, // <---
    }
});
        </code></pre>
<p>
Let's draw a simple red-ish gradient from top to bottom, and set that as our icon:
</p>
<pre class="rounded copy"><code class="language-cpp">
unsigned int icon_pixels[32*32];
for (int y = 0; y < 32; ++y) {
    for (int x = 0; x < 32; ++x) {

        float t = ((float)(y * 32 + x)) / (32.f * 32.f);

        t = (VD_FW_SIN(t * 2) + 1.0f) * 0.5f;

        float r = 0.7f * t;
        float g = 0.2f * t;
        float b = 0.0f * t;

        icon_pixels[y * 32 + x] = 0xFF << 24                       |
                                  ((unsigned char)(r * 255)) << 16 |
                                  ((unsigned char)(g * 255)) <<  8 |
                                  ((unsigned char)(b * 255)) <<  0;
    }
}
vd_fw_set_app_icon(icon_pixels, 32, 32);
        </code></pre>
<img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-appicon.gif" >
</img>
<p>
On Windows, the icon will also be shown in:
<ul>
<li>The App Bar (Taskbar), and</li>
<li>The Window switcher (Alt + Tab)</li>
</ul>
</p>
</section>
<br>
<section class="L2 section" id="use-the-discrete-gpu">
<h4>Use the Discrete GPU</h4>
<p>
The OpenGL specification makes no distinction between the presence of multiple GPUs inside
the target system; one will be automatically selected based on vendor preference settings
host OS, and other factors that the developer will not be able to affect.
</p>
<p>
However, for most systems there is a way to tell the OS at least what <i>kind</i> of GPU
the application prefers. This library can be instructed to do that through using:
</p>
<pre class="rounded copy"><code class="language-cpp">
#define VD_FW_PREFER_DISCRETE_GPU    // Prefer D-GPU
// Or
#define VD_FW_PREFER_INTEGRATED_GPU  // Prefer I-GPU (The one inside your CPU)
        </code></pre>
<p>
Of course, this doesn't mean that your target application will only use the GPU type you
specified, but it will signal to whatever system decides this that the application prefers
that type of GPU.
</p>
<p>
There are many more technicalities, the most important of which to know is: The OpenGL
backend will change/swap GPUs if run on an Optimus, or other kind of laptop that features
GPU switching. It will also change (depending on the operating system, version, etc.), if
the window enters a full-screen state. 
</p>
<p>
Most of these 2 GPU devices are high end gaming laptops, which use the integrated GPU for
low priority tasks, such as the web browser, and keep the discrete GPU turned off until a
demanding task, like a game needs it. 
</p>
<p>
My suggestion is:
<ul>
<li>
For GUI applications:<br> 
<b>Don't set any GPU preference</b>. These apps are supposed to use few system
resources anyway. This will guarantee that resizing, going fullscreen, etc.. will
match the display context to the currently used one by other applications.
</li>
<li>
For games:<br>
<b>Always use the discrete GPU</b>, since those are the ones that implement the most
OpenGL extensions, as well as the fastest ones. But be aware that initial startup
time (especially on gaming laptops with 2 GPUs), will be affected.        
</li>
</ul>
</p>
</section>
<br>
</section>
<section class="L1 section" id="reference">
<h4>Reference</h4>
<hr>
<section class="L2 section" id="input-mappings">
<h4>Input Mappings</h4>
<p>
This is a complete list of all possible input mappings supported by this library.
</p>
<p>
Alternatively, click below to open an interactive interface:
</p>
<div class="d-none d-lg-flex" >
<button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#keyboard-backdrop" >
Open Input Mappings
</button>
</div>
<br>
<p>
Here's all the mapped keybindings. For most of them, considerations were taken to map the values to ASCII
symbols that correspond to the physical key on a US ANSI/ISO keyboard layout.
</p>
<pre class="rounded copy"><code class="language-cpp">
enum {
    VD_FW_KEY_UNKNOWN       = 0,
    VD_FW_KEY_F1            = 1,
    VD_FW_KEY_F2            = 2,
    VD_FW_KEY_F3            = 3,
    VD_FW_KEY_F4            = 4,
    VD_FW_KEY_F5            = 5,
    VD_FW_KEY_F6            = 6,
    VD_FW_KEY_F7            = 7,
    VD_FW_KEY_F8            = 8,
    VD_FW_KEY_F9            = 9,
    VD_FW_KEY_F10           = 10,
    VD_FW_KEY_F11           = 11,
    VD_FW_KEY_F12           = 12,
    VD_FW_KEY_F13           = 13,
    VD_FW_KEY_F14           = 14,
    VD_FW_KEY_F15           = 15,
    VD_FW_KEY_F16           = 16,
    VD_FW_KEY_F17           = 17,
    VD_FW_KEY_F18           = 18,
    VD_FW_KEY_F19           = 19,
    VD_FW_KEY_F20           = 20,
    VD_FW_KEY_F21           = 21,
    VD_FW_KEY_F22           = 22,
    VD_FW_KEY_F23           = 23,
    VD_FW_KEY_F24           = 24,
    VD_FW_KEY_BACKSPACE     = 25,  
    VD_FW_KEY_INS           = 26,
    VD_FW_KEY_HOME          = 27,
    VD_FW_KEY_PGUP          = 28,
    VD_FW_KEY_DEL           = 29,
    VD_FW_KEY_END           = 30,
    VD_FW_KEY_PGDN          = 31,
    VD_FW_KEY_SPACE         = 32,  // ' ' 
    VD_FW_KEY_LCONTROL      = 33,
    VD_FW_KEY_RCONTROL      = 34,
    VD_FW_KEY_LALT          = 35,
    VD_FW_KEY_RALT          = 36,
    VD_FW_KEY_LSHIFT        = 37,
    VD_FW_KEY_RSHIFT        = 38,
    VD_FW_KEY_QUOTE         = 39,  // '\''
    VD_FW_KEY_ARROW_UP      = 40,
    VD_FW_KEY_ARROW_LEFT    = 41,
    VD_FW_KEY_ARROW_DOWN    = 42,
    VD_FW_KEY_ARROW_RIGHT   = 43,
    VD_FW_KEY_COMMA         = 44,  // ','
    VD_FW_KEY_MINUS         = 45,  // '-'
    VD_FW_KEY_DOT           = 46,  // '.'
    VD_FW_KEY_SLASH_FORWARD = 47,  // '/'
    VD_FW_KEY_0             = 48,  // '0'
    VD_FW_KEY_1             = 49,  // '1'
    VD_FW_KEY_2             = 50,  // '2'
    VD_FW_KEY_3             = 51,  // '3'
    VD_FW_KEY_4             = 52,  // '4'
    VD_FW_KEY_5             = 53,  // '5'
    VD_FW_KEY_6             = 54,  // '6'
    VD_FW_KEY_7             = 55,  // '7'
    VD_FW_KEY_8             = 56,  // '8'
    VD_FW_KEY_9             = 57,  // '9'
    VD_FW_KEY_ENTER         = 58,
    VD_FW_KEY_SEMICOLON     = 59,  // ';'
    VD_FW_KEY_TAB           = 60,
    VD_FW_KEY_EQUALS        = 61,  // '='
    VD_FW_KEY_CAPITAL       = 62,
    VD_FW_KEY_ESCAPE        = 63,
    VD_FW_KEY_RESERVED1     = 64,  // '@'
    VD_FW_KEY_A             = 65,  // 'A'
    VD_FW_KEY_B             = 66,  // 'B'
    VD_FW_KEY_C             = 67,  // 'C'
    VD_FW_KEY_D             = 68,  // 'D'
    VD_FW_KEY_E             = 69,  // 'E'
    VD_FW_KEY_F             = 70,  // 'F'
    VD_FW_KEY_G             = 71,  // 'G'
    VD_FW_KEY_H             = 72,  // 'H'
    VD_FW_KEY_I             = 73,  // 'I'
    VD_FW_KEY_J             = 74,  // 'J'
    VD_FW_KEY_K             = 75,  // 'K'
    VD_FW_KEY_L             = 76,  // 'L'
    VD_FW_KEY_M             = 77,  // 'M'
    VD_FW_KEY_N             = 78,  // 'N'
    VD_FW_KEY_O             = 79,  // 'O'
    VD_FW_KEY_P             = 80,  // 'P'
    VD_FW_KEY_Q             = 81,  // 'Q'
    VD_FW_KEY_R             = 82,  // 'R'
    VD_FW_KEY_S             = 83,  // 'S'
    VD_FW_KEY_T             = 84,  // 'T'
    VD_FW_KEY_U             = 85,  // 'U'
    VD_FW_KEY_V             = 86,  // 'V'
    VD_FW_KEY_W             = 87,  // 'W'
    VD_FW_KEY_X             = 88,  // 'X'
    VD_FW_KEY_Y             = 89,  // 'Y'
    VD_FW_KEY_Z             = 90,  // 'Z'
    VD_FW_KEY_BRACKET_OPEN  = 91,  // '['
    VD_FW_KEY_SLASH_BACK    = 92,  // '\\'
    VD_FW_KEY_BRACKET_CLOSE = 93,  // ']'
    VD_FW_KEY_MEDIA_NEXT    = 94,  // Media Next Track
    VD_FW_KEY_MEDIA_PREV    = 95,  // Media Prev Track
    VD_FW_KEY_BACKTICK      = 96,  // '`'
    VD_FW_KEY_MEDIA_PLAY    = 97,  // Media Play/Pause
    VD_FW_KEY_NUMPAD_0      = 98,  // Numpad 0
    VD_FW_KEY_NUMPAD_1      = 99,  // Numpad 1
    VD_FW_KEY_NUMPAD_2      = 100, // Numpad 2
    VD_FW_KEY_NUMPAD_3      = 101, // Numpad 3
    VD_FW_KEY_NUMPAD_4      = 102, // Numpad 4
    VD_FW_KEY_NUMPAD_5      = 103, // Numpad 5
    VD_FW_KEY_NUMPAD_6      = 104, // Numpad 6
    VD_FW_KEY_NUMPAD_7      = 105, // Numpad 7
    VD_FW_KEY_NUMPAD_8      = 106, // Numpad 8
    VD_FW_KEY_NUMPAD_9      = 107, // Numpad 9
    VD_FW_KEY_MAX,
};
        </code></pre>
</section>
<br>
<div id="vd_fw_init" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_init(VdFwInitInfo *info);
</span>
<div class="apidetails">
<p class="item-desc">
 Initialize fw. Call this before any other call

</p>
<table class="table">
<tbody>
<tr>
<td>info</td>
<td>
Custom options when initializing. Leave null for default

</td>
</tr>
<tr>
<td>Returns</td>
<td>
      (Reserved)

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_running" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_running(void);
</span>
<div class="apidetails">
<p class="item-desc">
 Check if the application is running. Call this every frame

</p>
<table class="table">
<tbody>
<tr>
<td>Returns</td>
<td>
  1 if running, 0 if not

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_swap_buffers" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_swap_buffers(void);
</span>
<div class="apidetails">
<p class="item-desc">
 End rendering and swap buffers. Call this right at the end of your rendering code.

</p>
<table class="table">
<tbody>
<tr>
<td>Returns</td>
<td>
  (Reserved)

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_size" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_get_size(int *w, int *h);
</span>
<div class="apidetails">
<p class="item-desc">
 Get the size of the window, in pixels

</p>
<table class="table">
<tbody>
<tr>
<td>w</td>
<td>
The width of the window, in pixels

</td>
</tr>
<tr>
<td>h</td>
<td>
The height of the window, in pixels

</td>
</tr>
<tr>
<td>Returns</td>
<td>
   (Reserved)

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_set_size" class="L2 apiitem function">
<span class="item-decl">void               vd_fw_set_size(int w, int h);
</span>
<div class="apidetails">
<p class="item-desc">
 Set the window size, in pixels

</p>
<table class="table">
<tbody>
<tr>
<td>w</td>
<td>
The width of the window, in pixels

</td>
</tr>
<tr>
<td>h</td>
<td>
The height of the window, in pixels

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_set_fullscreen" class="L2 apiitem function">
<span class="item-decl">void               vd_fw_set_fullscreen(int on);
</span>
<div class="apidetails">
<p class="item-desc">
 Enter/exit fullscreen.

</p>
<table class="table">
<tbody>
<tr>
<td>on</td>
<td>
Whether to enter or exit fullscreen.

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_fullscreen" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_get_fullscreen(void);
</span>
<div class="apidetails">
<p class="item-desc">
 Get current fullscreen state.

</p>
<table class="table">
<tbody>
<tr>
<td>Returns</td>
<td>
  1 if in fullscreen, 0 otherwise.

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_focused" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_get_focused(int *focused);
</span>
<div class="apidetails">
<p class="item-desc">
 Gets whether the window is focused

</p>
<table class="table">
<tbody>
<tr>
<td>focused</td>
<td>
Pointer to int which will receive the value of focus

</td>
</tr>
<tr>
<td>Returns</td>
<td>
         1 if the focus has changed. There's no point in checking the value of focused otherwise.

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_set_ncrects" class="L2 apiitem function">
<span class="item-decl">void               vd_fw_set_ncrects(int caption[4], int count, int (*rects)[4]);
</span>
<div class="apidetails">
<p class="item-desc">
 Set the draggable area of the window, any sub-rectangles to ignore

</p>
<table class="table">
<tbody>
<tr>
<td>caption</td>
<td>
The whole draggable area

</td>
</tr>
<tr>
<td>count</td>
<td>
The count of sub-rectangles that will be excluded from dragging

</td>
</tr>
<tr>
<td>rects</td>
<td>
An array of count rectangles to exclude

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_set_receive_ncmouse" class="L2 apiitem function">
<span class="item-decl">void               vd_fw_set_receive_ncmouse(int on);
</span>
<div class="apidetails">
<p class="item-desc">
 Set to receive mouse events outside of the non-client area

</p>
<table class="table">
<tbody>
<tr>
<td>on</td>
<td>
if you want to receive those events, 0 otherwise (default)

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_delta_ns" class="L2 apiitem function">
<span class="item-decl">unsigned long long vd_fw_delta_ns(void);
</span>
<div class="apidetails">
<p class="item-desc">
 Get the time (in nanoseconds) since the last call to vd_fw_swap_buffers

</p>
<table class="table">
<tbody>
<tr>
<td>Returns</td>
<td>
  The delta time (in nanoseconds)

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_delta_s" class="L2 apiitem function">
<span class="item-decl">float              vd_fw_delta_s(void);
</span>
<div class="apidetails">
<p class="item-desc">
 Get the time (in seconds) since the last call to vd_fw_swap_buffers

</p>
<table class="table">
<tbody>
<tr>
<td>Returns</td>
<td>
  The delta time (in seconds)

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_set_vsync_on" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_set_vsync_on(int on);
</span>
<div class="apidetails">
<p class="item-desc">
 Set the number of frames to sync on

</p>
<table class="table">
<tbody>
<tr>
<td>on</td>
<td>
Use: 0 for no sync, 1 for sync every frame and 2 for sync every other frame

</td>
</tr>
<tr>
<td>Returns</td>
<td>
 1 if the change was applied successfully

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_mouse_state" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_get_mouse_state(int *x, int *y);
</span>
<div class="apidetails">
<p class="item-desc">
 Read the mouse state.

</p>
<table class="table">
<tbody>
<tr>
<td>x</td>
<td>
The horizontal position of the mouse, in pixels (left -> right)

</td>
</tr>
<tr>
<td>y</td>
<td>
The vertical position of the mouse, in pixels (top -> bottom)

</td>
</tr>
<tr>
<td>Returns</td>
<td>
   The mouse button state

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_mouse_statef" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_get_mouse_statef(float *x, float *y);
</span>
<div class="apidetails">
<p class="item-desc">
 Read the mouse state (float version).

</p>
<table class="table">
<tbody>
<tr>
<td>x</td>
<td>
The horizontal position of the mouse, in pixels (left -> right)

</td>
</tr>
<tr>
<td>y</td>
<td>
The vertical position of the mouse, in pixels (top -> bottom)

</td>
</tr>
<tr>
<td>Returns</td>
<td>
   The mouse button state

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_set_mouse_capture" class="L2 apiitem function">
<span class="item-decl">void               vd_fw_set_mouse_capture(int on);
</span>
<div class="apidetails">
<p class="item-desc">
 Capture mouse and receive events outside of the window region.

</p>
<table class="table">
<tbody>
<tr>
<td>on</td>
<td>
Whether to set this behavior on (default: off).

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_mouse_delta" class="L2 apiitem function">
<span class="item-decl">void               vd_fw_get_mouse_delta(float *dx, float *dy);
</span>
<div class="apidetails">
<p class="item-desc">
 Get the mouse movement in raw smoothed pixels. Use this over computing delta yourself.

</p>
<table class="table">
<tbody>
<tr>
<td>dx</td>
<td>
The horizontal delta movement of the mouse

</td>
</tr>
<tr>
<td>dy</td>
<td>
The vertical delta movement of the mouse

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_set_mouse_locked" class="L2 apiitem function">
<span class="item-decl">void               vd_fw_set_mouse_locked(int locked);
</span>
<div class="apidetails">
<p class="item-desc">
 Lock/Unlock the mouse to the center of the window, hiding its cursor

</p>
<table class="table">
<tbody>
<tr>
<td>locked</td>
<td>
Whether to lock or unlock the mouse (default: unlocked)

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_mouse_locked" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_get_mouse_locked(void);
</span>
<div class="apidetails">
<p class="item-desc">
 Gets whether the mouse is locked (by vd_fw_set_mouse_locked).

</p>
<table class="table">
<tbody>
<tr>
<td>Returns</td>
<td>
  Whether the mouse is locked (1 or 0)

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_mouse_wheel" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_get_mouse_wheel(float *dx, float *dy);
</span>
<div class="apidetails">
<p class="item-desc">
 Read the mouse wheel state.

</p>
<table class="table">
<tbody>
<tr>
<td>dx</td>
<td>
The delta of horizontal wheel (either trackpad swipe right, or ctrl + mousewheel)

</td>
</tr>
<tr>
<td>dy</td>
<td>
The delta of vertical wheel

</td>
</tr>
<tr>
<td>Returns</td>
<td>
    1 if the wheel moved, 0 if not

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_key_pressed" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_get_key_pressed(int key);
</span>
<div class="apidetails">
<p class="item-desc">
 Get whether a key was just pressed this frame

</p>
<table class="table">
<tbody>
<tr>
<td>key</td>
<td>
The key to check

</td>
</tr>
<tr>
<td>Returns</td>
<td>
     Whether this key was pressed this frame

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_key_down" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_get_key_down(int key);
</span>
<div class="apidetails">
<p class="item-desc">
 Get the last known state of this key

</p>
<table class="table">
<tbody>
<tr>
<td>key</td>
<td>
The key to check

</td>
</tr>
<tr>
<td>Returns</td>
<td>
     Whether this key is down currently

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_key_name" class="L2 apiitem function">
<span class="item-decl">const char*        vd_fw_get_key_name(VdFwKey k);
</span>
<div class="apidetails">
<p class="item-desc">
 Convert key to string.

</p>
<table class="table">
<tbody>
<tr>
<td>k</td>
<td>
The key

</td>
</tr>
<tr>
<td>Returns</td>
<td>
   The key's name

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_get_scale" class="L2 apiitem function">
<span class="item-decl">float              vd_fw_get_scale(void);
</span>
<div class="apidetails">
<p class="item-desc">
 Gets the backing scale factor

</p>
<table class="table">
<tbody>
<tr>
<td>Returns</td>
<td>
  The backing scale factor (1.0f: 1:1 scale, 2.0f, 2:1 scale, etc...)

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_set_title" class="L2 apiitem function">
<span class="item-decl">void               vd_fw_set_title(const char *title);
</span>
<div class="apidetails">
<p class="item-desc">
 Set the title of the window

</p>
<table class="table">
<tbody>
<tr>
<td>title</td>
<td>
The new title of the window

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_set_app_icon" class="L2 apiitem function">
<span class="item-decl">void               vd_fw_set_app_icon(void *pixels, int width, int height);
</span>
<div class="apidetails">
<p class="item-desc">
 Set the icon of the window and application

</p>
<table class="table">
<tbody>
<tr>
<td>pixels</td>
<td>
A packed A8B8G8R8 pixel buffer

</td>
</tr>
<tr>
<td>width</td>
<td>
The width of the icon, in pixels, must be at least 16px

</td>
</tr>
<tr>
<td>height</td>
<td>
The height of the icon, in pixels, must be at least 16px

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_compile_shader" class="L2 apiitem function">
<span class="item-decl">unsigned int       vd_fw_compile_shader(unsigned int type, const char *source);
</span>
<div class="apidetails">
<p class="item-desc">
 Compile a GLSL shader and check for errors

</p>
<table class="table">
<tbody>
<tr>
<td>type</td>
<td>
The shader type

</td>
</tr>
<tr>
<td>source</td>
<td>
The shader source code

</td>
</tr>
<tr>
<td>Returns</td>
<td>
        The shader handle

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_link_program" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_link_program(unsigned int program);
</span>
<div class="apidetails">
<p class="item-desc">
 Link a GL program and check for errors

</p>
<table class="table">
<tbody>
<tr>
<td>program</td>
<td>
The program to link

</td>
</tr>
<tr>
<td>Returns</td>
<td>
         1 on success, 0 otherwise

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_compile_or_hotload_program" class="L2 apiitem function">
<span class="item-decl">int                vd_fw_compile_or_hotload_program(unsigned int *program, unsigned long long *last_compile, const char *vertex_file_path, const char *fragment_file_path);
</span>
<div class="apidetails">
<p class="item-desc">
 Compiles a program, if any of the shader sources have been modified. You should call this every frame

</p>
<table class="table">
<tbody>
<tr>
<td>program</td>
<td>
Pointer to program (GLuint), initialize it to zero before rendering loop

</td>
</tr>
<tr>
<td>last_compile</td>
<td>
Pointer to last compilation time, initialize it to zero before rendering loop, and don't use it in any other way

</td>
</tr>
<tr>
<td>vertex_file_path</td>
<td>
The relative (or absolute) path to the vertex shader source

</td>
</tr>
<tr>
<td>fragment_file_path</td>
<td>
The relative (or absolute) path to the fragment shader source

</td>
</tr>
<tr>
<td>Returns</td>
<td>
                    1 if successful, 0 if encountered any breaking error. You don't really need to check this.

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_u_ortho" class="L2 apiitem function">
<span class="item-decl">void            vd_fw_u_ortho(float left, float right, float bottom, float top, float near, float far, float out[16]);
</span>
<div class="apidetails">
<p class="item-desc">
 Construct an orthographic projection matrix

</p>
<table class="table">
<tbody>
<tr>
<td>left</td>
<td>
The left side

</td>
</tr>
<tr>
<td>right</td>
<td>
The right side

</td>
</tr>
<tr>
<td>top</td>
<td>
The top side

</td>
</tr>
<tr>
<td>bottom</td>
<td>
The bottom side

</td>
</tr>
<tr>
<td>near</td>
<td>
The near plane

</td>
</tr>
<tr>
<td>far</td>
<td>
The far plane

</td>
</tr>
<tr>
<td>out</td>
<td>
The output matrix

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_u_perspective" class="L2 apiitem function">
<span class="item-decl">void            vd_fw_u_perspective(float fov, float aspect, float near, float far, float out[16]);
</span>
<div class="apidetails">
<p class="item-desc">
 Construct a perspective projection matrix

</p>
<table class="table">
<tbody>
<tr>
<td>fov</td>
<td>
The vertical fov, in degrees

</td>
</tr>
<tr>
<td>aspect</td>
<td>
The aspect ratio

</td>
</tr>
<tr>
<td>far</td>
<td>
The far plane

</td>
</tr>
<tr>
<td>near</td>
<td>
The near plane

</td>
</tr>
<tr>
<td>out</td>
<td>
The output matrix

</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="vd_fw_u_lookat" class="L2 apiitem function">
<span class="item-decl">void            vd_fw_u_lookat(float eye[3], float target[3], float updir[3], float out[16]);
</span>
<div class="apidetails">
<p class="item-desc">
 Construct a view matrix

</p>
<table class="table">
<tbody>
<tr>
<td>eye</td>
<td>
Position of the camera

</td>
</tr>
<tr>
<td>target</td>
<td>
Look target position

</td>
</tr>
<tr>
<td>updir</td>
<td>
The up direction

</td>
</tr>
<tr>
<td>out</td>
<td>
The output matrix

</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
<div class="d-flex">
<span class="text-muted flex-grow-1 align-self-end">&copy; Michael Dodis, 2025-2026.</span>
<span class="text-muted flex-grow-0 text-end align-self-end">This page was created with DOCUSPEC</span>
</div>

<!-- Begin Keyboard -->
<div class="modal fade" id="keyboard-backdrop" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1" aria-labelledby="keyboard-backdrop-label" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title fs-5" id="keyboard-backdrop-label">Input Mappings</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close">
                </button>
            </div>

            <div class="modal-body">

                <style>
                    .keyboard {
                        border-radius: 8px;
                        padding: 4px;
                        background-color: rgba(201, 201, 201, 0.514);
                        margin: 4px;
                    }

                    .keyboard-row {
                        display: flex;
                        flex-direction: row;
                        margin-bottom: 4px;
                    }

                    .key {
                        --w: 48px;
                        height: 44px;
                        min-width: var(--w);
                        padding: 6px 8px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 4px;

                        background-color: var(--eerie-black);
                        padding: 4px 4px;
                        margin-right: 4px;
                        user-select: none;
                        transition: background-color 0.2s ease-in-out;
                    }

                    .key-size-b     { --w: 100px; }
                    .key-size-s     { --w: 74px;  }
                    .key-size-n0    { --w: 100px; text-align: left; }
                    .key-size-c     { --w: 86px;  }
                    .key-size-e     { --w: 114px; }
                    .key-size-hfs   { --w: 16px;  }
                    .key-size-hfsm  { --w: 28px;  }
                    .key-size-ls    { --w: 101px; }
                    .key-size-rs    { --w: 152px; }
                    .key-size-ct    { --w: 82px;  }
                    .key-size-al    { --w: 57px;  }
                    .key-size-space { --w: 300px; }
                    .key-clear {
                        opacity: 0.0;
                    }
                    .first-keyboard-row {
                        margin-bottom: 12px;
                    }

                    .input-split {
                        display: flex;
                        flex-direction: row;
                        justify-content: center;
                        /*align-items: flex-start;*/
                        align-items: center;
                    }

                    #keyboard-output {
                        display: flex;
                        flex-grow: 1;
                        height: 300px;
                        min-width: 100px;
                        margin: 2px 2px 2px 2px;
                    }
                    #keyboard-output code {
                        display: flex;
                        flex-grow: 1;
                        background: #222;
                        color: #eee;
                        padding: 16px;
                        white-space: pre;
                        overflow-y: auto;
                    }

                    .key.pressed {
                        background-color: var(--bittersweet);
                    }

                    .key-numpad-top {
                        border-bottom-right-radius: 0px;
                        border-bottom-left-radius: 0px;
                        transform: translateY(2px) scale(1.0, 1.1);
                    }

                    .key-numpad-bot {
                        border-top-right-radius: 0px;
                        border-top-left-radius: 0px;
                    }


                </style>

                <!-- Begin Split -->
                <div class="input-split">
                    <!-- <div id="keyboard-input"> -->
                        <!-- Begin keyboard-input60 -->
                        <div class="keyboard" id="keyboard-input60">
                            <div class="keyboard-row first-keyboard-row" data-row="0">
                                <div class="key small"                      data-fwcode="VD_FW_KEY_ESCAPE"                        data-key="`">ESC</div>
                                <div class="key key-clear"                  data-fwcode=""                                        data-key="null"></div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F1"                            data-key="f1">F1</div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F2"                            data-key="f2">F2</div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F3"                            data-key="f3">F3</div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F4"                            data-key="f4">F4</div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                    data-key="null"></div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F5"                            data-key="f5">F5</div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F6"                            data-key="f6">F6</div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F7"                            data-key="f7">F7</div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F8"                            data-key="f8">F8</div>
                                <div class="key key-size-hfsm key-clear"    data-fwcode="null"                                    data-key="null"></div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F9"                            data-key="f9">F9</div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F10"                           data-key="f10">F10</div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F11"                           data-key="f11">F11</div>
                                <div class="key"                            data-fwcode="VD_FW_KEY_F12"                           data-key="f12">F12</div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                    data-key="null"></div>
                                <div class="key"                            data-code="PrintScreen" data-fwcode="VD_FW_KEY_UNKNOWN" data-key="">PtSc</div>
                                <div class="key"                            data-code="ScrollLock"  data-fwcode="VD_FW_KEY_UNKNOWN" data-key="">Scr</div>
                                <div class="key"                            data-code="Pause"       data-fwcode="VD_FW_KEY_UNKNOWN" data-key="">Pause</div>
                            </div>
                            <div class="keyboard-row" data-row="1">
                                <div class="key small"                      data-code="Backquote" data-fwcode="VD_FW_KEY_BACKTICK"    data-key="`">`</div>
                                <div class="key"                            data-code="Digit1"    data-fwcode="VD_FW_KEY_1"           data-key="1">1</div>
                                <div class="key"                            data-code="Digit2"    data-fwcode="VD_FW_KEY_2"           data-key="2">2</div>
                                <div class="key"                            data-code="Digit3"    data-fwcode="VD_FW_KEY_3"           data-key="3">3</div>
                                <div class="key"                            data-code="Digit4"    data-fwcode="VD_FW_KEY_4"           data-key="4">4</div>
                                <div class="key"                            data-code="Digit5"    data-fwcode="VD_FW_KEY_5"           data-key="5">5</div>
                                <div class="key"                            data-code="Digit6"    data-fwcode="VD_FW_KEY_6"           data-key="6">6</div>
                                <div class="key"                            data-code="Digit7"    data-fwcode="VD_FW_KEY_7"           data-key="7">7</div>
                                <div class="key"                            data-code="Digit8"    data-fwcode="VD_FW_KEY_8"           data-key="8">8</div>
                                <div class="key"                            data-code="Digit9"    data-fwcode="VD_FW_KEY_9"           data-key="9">9</div>
                                <div class="key"                            data-code="Digit0"    data-fwcode="VD_FW_KEY_0"           data-key="0">0</div>
                                <div class="key"                            data-code="Minus"     data-fwcode="VD_FW_KEY_MINUS"       data-key="-"></div>
                                <div class="key"                            data-code="Equal"     data-fwcode="VD_FW_KEY_EQUALS"      data-key="=">=</div>
                                <div class="key key-size-b operator small"  data-code="Backspace" data-fwcode="VD_FW_KEY_BACKSPACE"   data-key="Backspace"></div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                        data-key="null"></div>
                                <div class="key"                            data-code="Insert"    data-fwcode="VD_FW_KEY_INS"         >Ins</div>
                                <div class="key"                            data-code="Home"      data-fwcode="VD_FW_KEY_HOME"        >Hme</div>
                                <div class="key"                            data-code="PageUp"    data-fwcode="VD_FW_KEY_PGUP"        >PgUp</div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                        data-key="null"></div>
                                <div class="key"                            data-code="NumLock"        data-fwcode="VD_FW_KEY_UNKNOWN"     >Num</div>
                                <div class="key"                            data-code="NumpadDivide"   data-fwcode="VD_FW_KEY_UNKNOWN"     >/</div>
                                <div class="key"                            data-code="NumpadMultiply" data-fwcode="VD_FW_KEY_UNKNOWN"     >*</div>
                                <div class="key"                            data-code="NumpadSubtract" data-fwcode="VD_FW_KEY_UNKNOWN"     >-</div>
                            </div>
                            <div class="keyboard-row" data-row="2">
                                <div class="key key-size-s operator wide"   data-code="Tab"          data-fwcode="VD_FW_KEY_TAB"           data-key="Tab">Tab</div>
                                <div class="key"                            data-code="KeyQ"         data-fwcode="VD_FW_KEY_Q"             data-key="q">Q</div>
                                <div class="key"                            data-code="KeyW"         data-fwcode="VD_FW_KEY_W"             data-key="w">W</div>
                                <div class="key"                            data-code="KeyE"         data-fwcode="VD_FW_KEY_E"             data-key="e">E</div>
                                <div class="key"                            data-code="KeyR"         data-fwcode="VD_FW_KEY_R"             data-key="r">R</div>
                                <div class="key"                            data-code="KeyT"         data-fwcode="VD_FW_KEY_T"             data-key="t">T</div>
                                <div class="key"                            data-code="KeyY"         data-fwcode="VD_FW_KEY_Y"             data-key="y">Y</div>
                                <div class="key"                            data-code="KeyU"         data-fwcode="VD_FW_KEY_U"             data-key="u">U</div>
                                <div class="key"                            data-code="KeyI"         data-fwcode="VD_FW_KEY_I"             data-key="i">I</div>
                                <div class="key"                            data-code="KeyO"         data-fwcode="VD_FW_KEY_O"             data-key="o">O</div>
                                <div class="key"                            data-code="KeyP"         data-fwcode="VD_FW_KEY_P"             data-key="p">P</div>
                                <div class="key"                            data-code="BracketLeft"  data-fwcode="VD_FW_KEY_BRACKET_OPEN"  data-key="[">[</div>
                                <div class="key"                            data-code="BracketRight" data-fwcode="VD_FW_KEY_BRACKET_CLOSE" data-key="]">]</div>
                                <div class="key key-size-s operator"        data-code="Backslash"    data-fwcode="VD_FW_KEY_SLASH_BACK"    data-key="\">\</div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                        data-key="null"></div>
                                <div class="key"                            data-code="Delete"       data-fwcode="VD_FW_KEY_DEL"         >Del</div>
                                <div class="key"                            data-code="End"          data-fwcode="VD_FW_KEY_END"         >End</div>
                                <div class="key"                            data-code="PageDown"     data-fwcode="VD_FW_KEY_PGDN"        >PgDn</div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                        data-key="null"></div>
                                <div class="key"                            data-code="Numpad7"      data-fwcode="VD_FW_KEY_NUMPAD_7"     >7</div>
                                <div class="key"                            data-code="Numpad8"      data-fwcode="VD_FW_KEY_NUMPAD_8"     >8</div>
                                <div class="key"                            data-code="Numpad9"      data-fwcode="VD_FW_KEY_NUMPAD_9"     >9</div>
                                <div class="key key-numpad-top"             data-code="NumpadAdd"    data-fwcode="VD_FW_KEY_UNKNOWN"      >+</div>
                            </div>
                            <div class="keyboard-row" data-row="3">
                                <div class="key key-size-c operator wider"   data-code="CapsLock"  data-fwcode="VD_FW_KEY_CAPITAL"         data-key="Caps">Caps</div>
                                <div class="key"                             data-code="KeyA"      data-fwcode="VD_FW_KEY_A"               data-key="a">A</div>
                                <div class="key"                             data-code="KeyS"      data-fwcode="VD_FW_KEY_S"               data-key="s">S</div>
                                <div class="key"                             data-code="KeyD"      data-fwcode="VD_FW_KEY_D"               data-key="d">D</div>
                                <div class="key"                             data-code="KeyF"      data-fwcode="VD_FW_KEY_F"               data-key="f">F</div>
                                <div class="key"                             data-code="KeyG"      data-fwcode="VD_FW_KEY_G"               data-key="g">G</div>
                                <div class="key"                             data-code="KeyH"      data-fwcode="VD_FW_KEY_H"               data-key="h">H</div>
                                <div class="key"                             data-code="KeyJ"      data-fwcode="VD_FW_KEY_J"               data-key="j">J</div>
                                <div class="key"                             data-code="KeyK"      data-fwcode="VD_FW_KEY_K"               data-key="k">K</div>
                                <div class="key"                             data-code="KeyL"      data-fwcode="VD_FW_KEY_L"               data-key="l">L</div>
                                <div class="key"                             data-code="Semicolon" data-fwcode="VD_FW_KEY_SEMICOLON"       data-key=";">;</div>
                                <div class="key"                             data-code="Quote"     data-fwcode="VD_FW_KEY_QUOTE"           data-key="'">'</div>
                                <div class="key operator key-size-e"         data-code="Enter"     data-fwcode="VD_FW_KEY_ENTER"           data-key="Enter">Enter</div>
                                <div class="key key-size-hfs key-clear"      data-fwcode="null"                                        data-key="null"></div>
                                <div class="key key-clear"                   data-fwcode="null"                                        data-key="null"></div>
                                <div class="key key-clear"                   data-fwcode="null"                                        data-key="null"></div>
                                <div class="key key-clear"                   data-fwcode="null"                                        data-key="null"></div>
                                <div class="key key-size-hfs key-clear"      data-fwcode="null"                                        data-key="null"></div>
                                <div class="key"                             data-code="Numpad4"      data-fwcode="VD_FW_KEY_NUMPAD_4"     >4</div>
                                <div class="key"                             data-code="Numpad5"      data-fwcode="VD_FW_KEY_NUMPAD_5"     >5</div>
                                <div class="key"                             data-code="Numpad6"      data-fwcode="VD_FW_KEY_NUMPAD_6"     >6</div>
                                <div class="key key-numpad-bot"              data-code="NumpadAdd"    data-fwcode="VD_FW_KEY_UNKNOWN"      ></div>
                            </div>
                            <div class="keyboard-row" data-row="4">
                                <div class="key key-size-ls operator wide"  data-code="ShiftLeft"  data-fwcode="VD_FW_KEY_LSHIFT"          data-key="Shift">Shift</div>
                                <div class="key"                            data-code="KeyZ"       data-fwcode="VD_FW_KEY_Z"               data-key="z">Z</div>
                                <div class="key"                            data-code="KeyX"       data-fwcode="VD_FW_KEY_X"               data-key="x">X</div>
                                <div class="key"                            data-code="KeyC"       data-fwcode="VD_FW_KEY_C"               data-key="c">C</div>
                                <div class="key"                            data-code="KeyV"       data-fwcode="VD_FW_KEY_V"               data-key="v">V</div>
                                <div class="key"                            data-code="KeyB"       data-fwcode="VD_FW_KEY_B"               data-key="b">B</div>
                                <div class="key"                            data-code="KeyN"       data-fwcode="VD_FW_KEY_N"               data-key="n">N</div>
                                <div class="key"                            data-code="KeyM"       data-fwcode="VD_FW_KEY_M"               data-key="m">M</div>
                                <div class="key"                            data-code="Comma"      data-fwcode="VD_FW_KEY_COMMA"           data-key=",">,</div>
                                <div class="key"                            data-code="Period"     data-fwcode="VD_FW_KEY_DOT"             data-key=".">.</div>
                                <div class="key"                            data-code="Slash"      data-fwcode="VD_FW_KEY_SLASH_FORWARD"   data-key="/">/</div>
                                <div class="key key-size-rs operator wide"  data-code="ShiftRight" data-fwcode="VD_FW_KEY_RSHIFT"          data-key="Shift">Shift</div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                             data-key="null"></div>
                                <div class="key key-clear"                                                                                 data-key="null"></div>
                                <div class="key"                            data-code="ArrowUp"    data-fwcode="VD_FW_KEY_ARROW_UP"        ></div>
                                <div class="key key-clear"                                                                                 data-key="null"></div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                        data-key="null"></div>
                                <div class="key"                            data-code="Numpad1"       data-fwcode="VD_FW_KEY_NUMPAD_1"     >1</div>
                                <div class="key"                            data-code="Numpad2"       data-fwcode="VD_FW_KEY_NUMPAD_2"     >2</div>
                                <div class="key"                            data-code="Numpad3"       data-fwcode="VD_FW_KEY_NUMPAD_3"     >3</div>
                                <div class="key key-numpad-top"             data-code="NumpadEnter"   data-fwcode="VD_FW_KEY_UNKNOWN"      >En</div>
                            </div>
                            <div class="keyboard-row" data-row="5">
                                <div class="key key-size-ct small operator" data-code="ControlLeft"   data-fwcode="VD_FW_KEY_LCONTROL"                      data-key="Ctrl">Ctrl</div>
                                <div class="key key-size-al small operator" data-code="MetaLeft"      data-fwcode="VD_FW_KEY_UNKNOWN"                       data-key="Meta">Win</div>
                                <div class="key key-size-al small operator" data-code="AltLeft"       data-fwcode="VD_FW_KEY_LALT"                          data-key="Alt">Alt</div>
                                <div class="key key-size-space extrawide"   data-code="Space"         data-fwcode="VD_FW_KEY_SPACE"                         data-key=" ">Space</div>
                                <div class="key key-size-al small operator" data-code="AltRight"      data-fwcode="VD_FW_KEY_RALT"                          data-key="AltGr">AltGr</div>
                                <div class="key key-size-al small operator"                           data-fwcode="VD_FW_KEY_UNKNOWN"                       data-key="Win">Win</div>
                                <div class="key key-size-al small operator" data-code="ContextMenu"   data-fwcode="VD_FW_KEY_UNKNOWN"                       data-key="Menu"></div>
                                <div class="key key-size-ct small operator" data-code="ControlRight"  data-fwcode="VD_FW_KEY_RCONTROL"                      data-key="Ctrl">Ctrl</div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                              data-key="null"></div>
                                <div class="key"                            data-code="ArrowLeft"     data-fwcode="VD_FW_KEY_ARROW_LEFT"        ></div>
                                <div class="key"                            data-code="ArrowDown"     data-fwcode="VD_FW_KEY_ARROW_DOWN"        ></div>
                                <div class="key"                            data-code="ArrowRight"    data-fwcode="VD_FW_KEY_ARROW_RIGHT"       ></div>
                                <div class="key key-size-hfs key-clear"     data-fwcode="null"                                              data-key="null"></div>
                                <div class="key key-size-n0"                data-code="Numpad0"       data-fwcode="VD_FW_KEY_NUMPAD_0"       >0</div>
                                <div class="key"                            data-code="NumpadDecimal" data-fwcode="VD_FW_KEY_UNKNOWN"     >.</div>
                                <div class="key key-numpad-bot"             data-code="NumpadEnter"   data-fwcode="VD_FW_KEY_UNKNOWN"      ></div>
                            </div>
                        </div>
                        <!-- End   keyboard-input60 -->
                    <!-- </div> -->

                    <div id="keyboard-output" class="flex-column">
                        <div class="d-flex flex-row justify-content-between align-items-center">
                            <p>
                                Click anywhere on the keyboard, or use your own keyboard.
                            </p>
                            <button type="button" class="btn btn-primary" onclick="clearKeyboardOutput();">Clear</button>
                        </div>
                        <code></code>
                    </div>
                </div>
                <!-- End  Split -->
                
            </div>
        </div>
    </div>
</div>
<!-- End   Keyboard -->
<script >

let keyboardInitialized = false;
let keyboardShown = false;

const keyboardInput  = document.getElementById('keyboard-input60');
const keyboardOutput = document.getElementById('keyboard-output');
const keyboardCode = keyboardOutput.querySelector('code');
function activateKeyboard() {
    keyboardShown = true;
    keyboardCode.textContent = '';
    
    if (keyboardInitialized) return;
    keyboardInitialized = true;
    
    function findVisualKeyForEvent(e){
        // match by code first, fall back to matching by printed key (case-insensitive)
        const byCode = document.querySelector(`[data-code="${e.code}"]`);
        if(byCode) return byCode;
        const candidate = Array.from(keyboardInput.querySelectorAll('.key')).find(k=>{
            const dk = k.dataset.key;
            return dk && dk.toLowerCase() === e.key.toLowerCase();
        });
        return candidate || null;
    }
    
    function flashKey(keyEl) {
        keyEl.classList.add('pressed');
        setTimeout(() => keyEl.classList.remove('pressed'), 140);
    }
    
    function showKey(fwkey){
        const code = fwkey || 'Unknown';
        if (!(fwkey === "null" || fwkey === "Unknown")) {
            keyboardCode.textContent = code + "\n" + keyboardCode.textContent;
        }
    }
    
    window.addEventListener('keydown', event => {
        if (!keyboardShown) return;
        if (document.activeElement !== keyboardInput) return;
        // event.preventDefault();
        const visual = findVisualKeyForEvent(event);
        if (visual) {
            flashKey(visual);
            showKey(visual.dataset.fwcode);
        }
    });
    
    keyboardInput.addEventListener('click', event => {
        const keyEl = event.target.closest('.key');
        if (keyEl) {
            flashKey(keyEl);
            showKey(keyEl.dataset.fwcode);
        }
    });
}

document.getElementById('keyboard-backdrop').addEventListener('shown.bs.modal', function () {
    activateKeyboard();
    if (keyboardInput) {
        keyboardInput.setAttribute('tabindex', '0');
        keyboardInput.focus();
    }
});

document.getElementById('keyboard-backdrop').addEventListener('hidden.bs.modal', function () {
    keyboardShown = false;
});

function clearKeyboardOutput() {
    keyboardCode.textContent = '';
}
</script>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
<script src="/auto-toc.js"></script>
<script src="/search.js"></script>
<script src="/index.js"></script>
</body>
</html>
