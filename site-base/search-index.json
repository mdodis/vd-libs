[
{
"id": 1,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_init",
"subtitle": "vd_fw_init",
"contents": "vd_fw_init"}
,{
"id": 2,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_running",
"subtitle": "vd_fw_running",
"contents": "vd_fw_running"}
,{
"id": 3,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_swap_buffers",
"subtitle": "vd_fw_swap_buffers",
"contents": "vd_fw_swap_buffers"}
,{
"id": 4,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_size",
"subtitle": "vd_fw_get_size",
"contents": "vd_fw_get_size"}
,{
"id": 5,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_set_size",
"subtitle": "vd_fw_set_size",
"contents": "vd_fw_set_size"}
,{
"id": 6,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_set_fullscreen",
"subtitle": "vd_fw_set_fullscreen",
"contents": "vd_fw_set_fullscreen"}
,{
"id": 7,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_fullscreen",
"subtitle": "vd_fw_get_fullscreen",
"contents": "vd_fw_get_fullscreen"}
,{
"id": 8,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_focused",
"subtitle": "vd_fw_get_focused",
"contents": "vd_fw_get_focused"}
,{
"id": 9,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_set_ncrects",
"subtitle": "vd_fw_set_ncrects",
"contents": "vd_fw_set_ncrects"}
,{
"id": 10,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_set_receive_ncmouse",
"subtitle": "vd_fw_set_receive_ncmouse",
"contents": "vd_fw_set_receive_ncmouse"}
,{
"id": 11,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_delta_ns",
"subtitle": "vd_fw_delta_ns",
"contents": "vd_fw_delta_ns"}
,{
"id": 12,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_delta_s",
"subtitle": "vd_fw_delta_s",
"contents": "vd_fw_delta_s"}
,{
"id": 13,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_set_vsync_on",
"subtitle": "vd_fw_set_vsync_on",
"contents": "vd_fw_set_vsync_on"}
,{
"id": 14,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_mouse_state",
"subtitle": "vd_fw_get_mouse_state",
"contents": "vd_fw_get_mouse_state"}
,{
"id": 15,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_mouse_statef",
"subtitle": "vd_fw_get_mouse_statef",
"contents": "vd_fw_get_mouse_statef"}
,{
"id": 16,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_set_mouse_capture",
"subtitle": "vd_fw_set_mouse_capture",
"contents": "vd_fw_set_mouse_capture"}
,{
"id": 17,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_mouse_delta",
"subtitle": "vd_fw_get_mouse_delta",
"contents": "vd_fw_get_mouse_delta"}
,{
"id": 18,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_set_mouse_locked",
"subtitle": "vd_fw_set_mouse_locked",
"contents": "vd_fw_set_mouse_locked"}
,{
"id": 19,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_mouse_locked",
"subtitle": "vd_fw_get_mouse_locked",
"contents": "vd_fw_get_mouse_locked"}
,{
"id": 20,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_mouse_wheel",
"subtitle": "vd_fw_get_mouse_wheel",
"contents": "vd_fw_get_mouse_wheel"}
,{
"id": 21,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_key_pressed",
"subtitle": "vd_fw_get_key_pressed",
"contents": "vd_fw_get_key_pressed"}
,{
"id": 22,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_key_down",
"subtitle": "vd_fw_get_key_down",
"contents": "vd_fw_get_key_down"}
,{
"id": 23,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_key_name",
"subtitle": "vd_fw_get_key_name",
"contents": "vd_fw_get_key_name"}
,{
"id": 24,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_get_scale",
"subtitle": "vd_fw_get_scale",
"contents": "vd_fw_get_scale"}
,{
"id": 25,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_set_title",
"subtitle": "vd_fw_set_title",
"contents": "vd_fw_set_title"}
,{
"id": 26,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_set_app_icon",
"subtitle": "vd_fw_set_app_icon",
"contents": "vd_fw_set_app_icon"}
,{
"id": 27,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_compile_shader",
"subtitle": "vd_fw_compile_shader",
"contents": "vd_fw_compile_shader"}
,{
"id": 28,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_link_program",
"subtitle": "vd_fw_link_program",
"contents": "vd_fw_link_program"}
,{
"id": 29,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_compile_or_hotload_program",
"subtitle": "vd_fw_compile_or_hotload_program",
"contents": "vd_fw_compile_or_hotload_program"}
,{
"id": 30,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_u_ortho",
"subtitle": "vd_fw_u_ortho",
"contents": "vd_fw_u_ortho"}
,{
"id": 31,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_u_perspective",
"subtitle": "vd_fw_u_perspective",
"contents": "vd_fw_u_perspective"}
,{
"id": 32,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "vd_fw_u_lookat",
"subtitle": "vd_fw_u_lookat",
"contents": "vd_fw_u_lookat"}
,{
"id": 33,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "brief",
"subtitle": "Brief",
"contents": "A <b>header-only</b> library that gets you a semi-customizable window and an OpenGL context, minimizingdependencies and hiding the complexities of doing proper windowing on each platform.Its written with performance in mind; though performance is not the main focus of it.<b>Maintainability</b>, <b>support</b> for the defined feature set and <b>ease of use</b>are the primary targets of this library.This library can:<ul><li>Open a window, handle input from keyboard/mouse/controller</li><li>Draw while resizing the window</li><li>Disable window decorations, but still be able to tile the window, customize the drag area, etc...</li><li>Load OpenGL (without using a loader library)</li><li>Set the window icon</li><li>All of that, with as minimal dependencies as possible (for example, you dont even need to link to orhave the development headers/libraries of X11/OpenGL, etc. on linux)</li></ul>The main idea of this library is that you shouldnt need to think about installing CMake, or messing with yourbuild tools link paths, <i>just</i> to be able to draw some stuff using the GPU.It should be easy to just drop inright inside of your project, and start developing, with full access to a relatively small source code size.Additionally, this library:<ul><li>Provides custom implementations of several math functions, like sinf</li><li>Doesnt use the standard C library (where possible)</li><li>Prodives convenience functions that can, for example, construct a perpsective projection matrix for OpenGL</li><li>Automatically sets up OpenGL debugging infrastructure</li></ul><b>Why should you use this library over, GLFW, SDL, SFML, ...?</b><br>Those libraries solve a <b>much more</b> general problem than the one most developers have:<ul><li>Create one or more windows</li><li>Handle child/parent window relationships</li><li>Provide aliases for common usermode operations (show file dialog, message box)</li><li>Support many more platforms, even ones that dont include a windowing system.</li><li>Support multiple graphics APIs for initialization.</li><li>Provide a high level drawing interface.</li><li>Provide a high level sound interface.</li><li>Allow for entirely customized windows.</li><li>And much more...</li></ul>But in their attempt to be generic and robust, they fail to provide a good and simpleinterface that covers 90% of the use cases, and is implemented in the best way possible foreach platform.One common example is that almost every popular windowing library on Windows does not allowthe developer to draw while resizing or moving the window.This is an introcacy of the Win32 API (and actually the same is true for MacOS), and therecommended way is not exactly obvious to a new developer, or one unfamiliar with theplatform.<br>Note that you dont need to use an OpenGL loader or include any OS specific OpenGLlibraries.<br>The library does the loading for you.Here is all you need (and should need) to create a simple window.<br>By default it creates an OpenGL 3.3 core profile context:#include vd_fw.h                                           // Include library  int main() {      vd_fw_init(NULL);                                        // Initialize library      while (vd_fw_running()) {                                // Check if the window is closed & gather events          glClearColor(0.5f, 0.3f, 0.2f, 1.0f);          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);          vd_fw_swap_buffers();                                // Swap buffers      }      return 0;  }    #define VD_FW_IMPL                                           // Include implementation code  #include vd_fw.h      PDFDownload"}
,{
"id": 34,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "linking-and-dependencies",
"subtitle": "Linking & Dependencies",
"contents": "This library is distributed as a single, header-only file, thus the following instructionsare meant to be considered for your final application/dynamic library.<br> <br>In general, I make use of the up-to-date platform specific APIs, that should be availablewith every distribution of said platforms development environment.<br> <br>Some preprocessor directives to set depending on your needs:Option Description <code>VD_FW_VERSION_MAJOR</code>Major version number of the library<code>VD_FW_VERSION_MINOR</code>Minor version number of the library<code>VD_FW_VERSION_PATCH</code>Patch version number of the library<code>VD_FW_VERSION</code>Combined version (major, minor, patch) number of the library<code>#define VD_FW_STATIC</code>Set to use this library statically.<code>#define VD_FW_API // (static, extern, ...dllexport)</code>Set to change the function signature (useful for precompiling the library).<code>#define VD_FW_INLSet to change the function signature (useful for precompiling the library).<code>#define VD_FW_NO_CRT</code>Options:<ul><li>Set to 1 to disable including C standard library</li><li>Set to 0 to enable including C standard library</li></ul><code>#define VD_FW_SIN</code>Can be predefined to your implementation of sinf.Options:<ul><li>If <code>VD_FW_NO_CRT == 1</code> its resolved to libc <code>sinf</code></li><li>If <code>VD_FW_NO_CRT == 0</code> its resolved to vd_fw_sin (custom implementation).</li></ul><code>#define VD_FW_COS</code>Can be predefined to your implementation of cosf.Options:<ul><li>If <code>VD_FW_NO_CRT == 1</code> its resolved to libc <code>cosf</code></li><li>If <code>VD_FW_NO_CRT == 0</code> its resolved to vd_fw_cos (custom implementation).</li></ul><code>#define VD_FW_TAN</code>Can be predefined to your implementation of tanf.Options:<ul><li>If <code>VD_FW_NO_CRT == 1</code> its resolved to libc <code>tanf</code></li><li>If <code>VD_FW_NO_CRT == 0</code> its resolved to vd_fw_tan (custom implementation).</li></ul><code>#define VD_FW_SQRT</code>Can be predefined to your implementation of sqrtf.Options:<ul><li>If <code>VD_FW_NO_CRT == 1</code> its resolved to libc <code>sqrtf</code></li><li>If <code>VD_FW_NO_CRT == 0</code> its resolved to vd_fw_sqrt (custom implementation).</li></ul><code>#define VD_FW_MEMCPY</code>Can be predefined to your implementation of memcpy.Options:<ul><li>If <code>VD_FW_NO_CRT == 1</code> its resolved to libc <code>memcpy</code></li><li>If <code>VD_FW_NO_CRT == 0</code> its resolved to vd_fw_memcpy (custom implementation).</li></ul><code>#define VD_FW_MEMSET</code>Can be predefined to your implementation of memset.Options:<ul><li>If <code>VD_FW_NO_CRT == 1</code> its resolved to libc <code>memset</code></li><li>If <code>VD_FW_NO_CRT == 0</code> its resolved to vd_fw_memset (custom implementation).</li></ul><code>#define VD_FW_PREFER_DISCRETE_GPU</code><br><code>// Or</code><br><code>#define VD_FW_PREFER_INTEGRATED_GPU</code><br>Change the preferred GPU for the OpenGL context.<b>Win32 Specific</b><code>#define VD_FW_WIN32_SUBSYSTEM</code><br><code>// Can be one of the following:</code><br><code>// VD_FW_WIN32_SUBSYSTEM_CONSOLE</code><br><code>// VD_FW_WIN32_SUBSYSTEM_WINDOWS</code>Change the <a href=https://learn.microsoft.com/en-us/cpp/build/reference/subsystem-specify-subsystem?view=msvc-170>Subsystem</a>(Windows only).<code>#define VD_FW_WIN32_NO_LINKER_COMMENTS</code>Disable automatic linker comments (Windows only)."}
,{
"id": 35,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "windows",
"subtitle": "Windows",
"contents": "With MSVC you dont really need to link anything since linker directives in thetranslation unit that includes vd_fw.h are defined, so that the appropriate librariesand subsystem are used. Additionally, several core libraries are <b>dynamically</b> loaded in vd_fw_init.The only library required during compilation is <code>kernel32.lib</code>. For reference, here are thelibraries this library tries to load during vd_fw_init:<ol class=list-group><li class=list-group-item>User32</li><li class=list-group-item>OpenGL32</li><li class=list-group-item>Dwmapi</li><li class=list-group-item>Gdi32</li><li class=list-group-item>uxtheme</li><li class=list-group-item>shell32</li><li class=list-group-item>winmm</li></ol><br>This library tries as much as possible to reduce the amount of code brought in with the (notoriously large)Windows includes. This is done by manually declaring enumerations, preprocessor macros, function signatures,and structures right inside the implementation part of the library. This looks like this:typedef struct VdFwtagRGBQUAD {      VdFwBYTE    rgbBlue;      VdFwBYTE    rgbGreen;      VdFwBYTE    rgbRed;      VdFwBYTE    rgbReserved;  } VdFwRGBQUAD;    typedef struct VdFwtagBITMAPINFO {      VdFwBITMAPINFOHEADER    bmiHeader;      VdFwRGBQUAD             bmiColors[1];  } VdFwBITMAPINFO, * VdFwLPBITMAPINFO, * VdFwPBITMAPINFO;    #define VD_FW_PROC_ChoosePixelFormat(name) int name(VdFwHDC hdc, const VdFwPIXELFORMATDESCRIPTOR *ppfd)  typedef VD_FW_PROC_ChoosePixelFormat(VdFwProcChoosePixelFormat);  static VdFwProcChoosePixelFormat *VdFwChoosePixelFormat;    #define VD_FW_PROC_CreateBitmap(name) VdFwHBITMAP name(int nWidth, int nHeight, VdFwUINT nPlanes, VdFwUINT nBitCount, const void* lpBits)  typedef VD_FW_PROC_CreateBitmap(VdFwProcCreateBitmap);  static VdFwProcCreateBitmap *VdFwCreateBitmap;          The relevant functions are then loaded when you call vd_fw_init:HMODULE m             = LoadLibraryA(Gdi32.dll);  VdFwChoosePixelFormat     =     (VdFwProcChoosePixelFormat*)GetProcAddress(m, ChoosePixelFormat);  VdFwCreateBitmap          =          (VdFwProcCreateBitmap*)GetProcAddress(m, CreateBitmap);          Note that all platform specific functions/typedefs/structs are prefixed with VdFw or VD_FW_ so as not toinduce collisions in cases where you need to include Windows functionality yourself.To set the subsystem of the application: <ul><li> Windows: <code>#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_WINDOWS</code> </li><li> Console: <code>#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_CONSOLE</code> </li></ul>If youre on the Windows subsystem, but would still like a console for debugging purposes, thiscan be done by setting <code>VdFwInitInfo::gl_options::debug_on = 1</code> when calling<code>vd_fw_init</code>.<br>This will allocate a console and set-up the relevant gl debug callback for you.Its highly recommended to <code>#define VD_FW_NO_CRT 1</code> so that the CRT is removedwhen linking. This can reduce the final executable size by a factor of 10 (for small applications).If youd like to define options by yourself,<code>#define VD_FW_WIN32_NO_LINKER_COMMENTS</code> before including the implementation."}
,{
"id": 36,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "macos",
"subtitle": "MacOS",
"contents": "For MacOS, its a bit different. with clang, you must link several frameworks (via <code>-framework framework_name</code>). Additionally, <code>-x objective-c</code> must be used since theMac APIs use Objective-C.<ol class=list-group><li class=list-group-item>pthread (compiler flag)</li><li class=list-group-item>Cocoa</li><li class=list-group-item>Metal</li><li class=list-group-item>QuartzCore</li><li class=list-group-item>CoreGraphics</li><li class=list-group-item>IOSurface</li><li class=list-group-item>IOKit</li><li class=list-group-item>Foundation</li><li class=list-group-item>OpenGL</li></ol>OpenGL on MacOS is deprecated, and including it will throw a ton of warnings abouteach function. Its maximum supported version of OpenGL is <b>4.1</b>.To disable those warnings, you can create the following header file and use itbefore and after including vd_fw.h:#ifndef DISABLE_CLANG_DEPRECATIONS_H1  #define DISABLE_CLANG_DEPRECATIONS_H1  #if defined(__clang__)  #pragma clang diagnostic push  #pragma clang diagnostic ignored -Wdeprecated-declarations  #endif // defined(__clang__)  #else  #if defined(__clang__)  #pragma clang diagnostic pop  #endif // defined(__clang__)  #endif // DISABLE_CLANG_DEPRECATIONS_H1          "}
,{
"id": 37,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "support",
"subtitle": "Support",
"contents": "zlib License    (C) Copyright 2025-2026 Michael Dodis (michaeldodisgr@gmail.com)   This software is provided as-is, without any express or implied  warranty.  In no event will the authors be held liable for any damages  arising from the use of this software.    Permission is granted to anyone to use this software for any purpose,  including commercial applications, and to alter it and redistribute it  freely, subject to the following restrictions:    1. The origin of this software must not be misrepresented; you must not     claim that you wrote the original software. If you use this software     in a product, an acknowledgment in the product documentation would be     appreciated but is not required.  2. Altered source versions must be plainly marked as such, and must not be     misrepresented as being the original software.  3. This notice may not be removed or altered from any source distribution.          As stated in the license, no warranty or guarantee is provided by the use of this library.That being said, I will look at issues when I have the time, and/or if they are important to the coreprinciples of this library.<a class=link-opacity-100 href=https://github.com/mdodis/vd-libs/issues/new>Submit issues here</a>"}
,{
"id": 38,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "platforms",
"subtitle": "Platforms",
"contents": "Due to platform limitations, platform-specific APIs and frameworks, vd_fw.h willnever have support for some platforms. One example is Android, where Java is required.Though, Im still thinking about how this can be done easily, so I will leave the possibilityopen.PlatformSupportedWindowsYesMacOSIn ProgressLinux (X11)In ProgressLinux (Wayland)PlannediOSPlannedAndroidNot PlannedWebNot Planned"}
,{
"id": 39,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "revisions",
"subtitle": "Revisions",
"contents": "<ul><li>Audio Buffer</li><li>Distribution</li><li>GL Extensions</li></ul>Initial Release:<ul><li>Win32 support</li><li>MacOS support</li></ul>"}
,{
"id": 40,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "attributions",
"subtitle": "Attributions",
"contents": "<ul><li><a href=https://github.com/CookedNick>CookedNick</a><br>For the render thread with Win32 example in jai</li><li><a href=https://github.com/idrassi/>idrassi</a><br>For the ported jai code for Win32 example</li><li><a href=https://github.com/melak47/BorderlessWindow>melak47</a><br>For the borderless window with Win32 example</li><li><a href=https://github.com/TheoBendixson>TheoBendixson</a><br>For his Handmade Mac platform layer</li></ul>"}
,{
"id": 41,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "tutorials",
"subtitle": "Tutorials",
"contents": "A collection of tutorials for how to use the library.These do not show proper code, nor do they show correct OpenGL API usage, but they show variousfeatures of vd_fw.hWe will start by creating a simple window, and continue with:<ul><li>Making it borderless</li><li>Drawing a rectangle</li><li>Setting the drag area</li><li>Drawing some 3D geometry</li><li>Handling input in a user-friendly way</li></ul>You can safely read each tutorial on its own, or in order. It will guide you throughalmost all of the parts of the APIAdditionally, several samples are available <a href=https://github.com/mdodis/vd-libs/tree/main/samples>here</a>,which map to several parts of the tutorial.This tutorial is written in C, but you can safely use C++ with it"}
,{
"id": 42,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "main-loop",
"subtitle": "Main Loop",
"contents": "Lets look at the main loop.#define VD_FW_NO_CRT 0                                       // Disable CRT, this is highly recommended,                                                               // if you know what youre doing.  #define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_WINDOWS  // Disable console (Windows)  #include vd_fw.h    int main(int argc, char const *argv[])  {      vd_fw_init(NULL);                                        // Initialize library      vd_fw_set_vsync_on(1);                                   // Enable VSYNC        while (vd_fw_running()) {                                // Check if user closed the window            int w, h;          vd_fw_get_size(&w, &h);                              // Get window size, in pixels.            glViewport(0, 0, w, h);                              // Setup viewport          glClearColor(0.5f, 0.3f, 0.2f, 1.0f);                // Select clear color          glClear(GL_COLOR_BUFFER_BIT);                        // Clear            vd_fw_swap_buffers();                                // Swap buffers      }        return 0;  }    #define VD_FW_IMPL                                           // Include implementation  #include vd_fw.h            This will create a window, that can be moved and resized."}
,{
"id": 43,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "choose-opengl-version",
"subtitle": "Choose OpenGL Version",
"contents": "To specify the OpenGL version, create a <code>VdFwInitInfo</code> struct, populate the<code>VdFwInitInfo::gl::version</code> member, and pass it to <code>vd_fw_init</code>.VdFwInitInfo init_info = {};  init_info.gl.version = VD_FW_GL_VERSION_4_5; // Set OpenGL Version  vd_fw_init(&init_info);          For reference, heres all of the possible versions:typedef enum {      VD_FW_GL_VERSION_BASIC = 0,      VD_FW_GL_VERSION_1_0   = 1,      VD_FW_GL_VERSION_1_2   = 12,      VD_FW_GL_VERSION_1_3   = 13,      VD_FW_GL_VERSION_1_4   = 14,      VD_FW_GL_VERSION_1_5   = 15,      VD_FW_GL_VERSION_2_0   = 20,      VD_FW_GL_VERSION_2_1   = 21,      VD_FW_GL_VERSION_3_0   = 30,      VD_FW_GL_VERSION_3_1   = 31,      VD_FW_GL_VERSION_3_2   = 32,      VD_FW_GL_VERSION_3_3   = 33,      VD_FW_GL_VERSION_4_0   = 40,      VD_FW_GL_VERSION_4_1   = 41,      VD_FW_GL_VERSION_4_2   = 42,      VD_FW_GL_VERSION_4_3   = 43,      VD_FW_GL_VERSION_4_4   = 44,      VD_FW_GL_VERSION_4_5   = 45,      VD_FW_GL_VERSION_4_6   = 46,  } VdFwGlVersion;          "}
,{
"id": 44,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "create-a-borderless-window",
"subtitle": "Create a Borderless Window",
"contents": "To create a borderless window, create a <code>VdFwInitInfo</code> struct, set<code>VdFwInitInfo::window_options::borderless</code> to 1, and pass it to <code>vd_fw_init</code>.VdFwInitInfo init_info = {};  init_info.window_options.borderless = 1;  vd_fw_init(&init_info);          This will create a borderless window, that can be moved (by dragging any part of the window), and resized."}
,{
"id": 45,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "create-a-shader-program",
"subtitle": "Create a Shader Program",
"contents": "Lets create a simple 2D rectangle application.Well create some in-source shaders, and compile them, as we would in any OpenGL application.If youd like to follow along, here are the shaders well be using:#define VERTEX_SOURCE   #version 330 core                                                                                                 n   layout (location = 0) in vec2 aPos;                                                                               n                                                                                                                     n   uniform vec2 rect_off;                                                                                            n   uniform vec2 rect_size;                                                                                           n   uniform mat4 projection;                                                                                          n                                                                                                                     n                                                                                                                     n   void main()                                                                                                       n   {                                                                                                                 n       gl_Position = projection * vec4(aPos * rect_size + rect_off, 0.0, 1.0f);                                      n   }                                                                                                                 n     #define FRAGMENT_SOURCE   #version 330 core                                                                                                 n   out vec4 FragColor;                                                                                               n                                                                                                                     n   uniform vec4 rect_color;                                                                                          n                                                                                                                     n   void main()                                                                                                       n   {                                                                                                                 n       FragColor = rect_color;                                                                                       n   }                                                                                                                 n           And the typical OpenGL shader compilation code:const char *vertex_shader_source = VERTEX_SOURCE;  const char *fragment_shader_source = FRAGMENT_SOURCE;    // Compile shaders  GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);  glShaderSource(vertex_shader, 1, &vertex_shader_source, 0);  glCompileShader(vertex_shader);    GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);  glShaderSource(fragment_shader, 1, &fragment_shader_source, 0);  glCompileShader(fragment_shader);    GLuint program = glCreateProgram();  glAttachShader(program, vertex_shader);  glAttachShader(program, fragment_shader);  glLinkProgram(program);          In most tutorials, youll be prompted to do error checking by doing <code>glGetShaderiv</code>,then <code>glGetShaderInfoLog</code> and printing it out...This library provides a convenience function (and more) to do that, and will also log the errors:GLuint vertex_shader   = vd_fw_compile_shader(GL_VERTEX_SHADER,   VERTEX_SOURCE);  GLuint fragment_shader = vd_fw_compile_shader(GL_FRAGMENT_SHADER, FRAGMENT_SOURCE);          For error logging, make sure to set <code>VdFwInitInfo::gl::debug_on</code> to 1 when initializing the library.Heres the <code>vd_fw_init</code> call well be using for the rest of these tutorials:vd_fw_init(& (VdFwInitInfo) {      .gl = {          .version = VD_FW_GL_VERSION_3_3,          .debug_on = 1,      },      .window_options = {          .borderless = 1,      }  });          "}
,{
"id": 46,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "draw-a-rectangle",
"subtitle": "Draw a Rectangle",
"contents": "Continuing from the previous section, we create a vertex buffer for a 2d rectangle:float rect_vertices[] = {       0.0f,  0.0f,      +1.0f,  0.0f,       0.0f, +1.0f,      +1.0f, +1.0f  };    unsigned int VBO, VAO;  glGenVertexArrays(1, &VAO);  glGenBuffers(1, &VBO);  glBindVertexArray(VAO);  glBindBuffer(GL_ARRAY_BUFFER, VBO);  glBufferData(GL_ARRAY_BUFFER, sizeof(rect_vertices), rect_vertices, GL_STATIC_DRAW);  glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);  glEnableVertexAttribArray(0);          And now for drawing a rectangle.Well use orthographic projection. vd_fw.h provides a simple utility function to compute it:<code>vd_fw_u_ortho</code>glUseProgram(program);  glBindVertexArray(VAO);    {      float projection[16];      vd_fw_u_ortho(0.f, (float)w, (float)h, 0.f, -1.f, 1.f, projection);      glUniformMatrix4fv(glGetUniformLocation(program, projection), 1, GL_FALSE, projection);  }          To test that the coordinate transformation is working, well map the top left of the rectangleto the mouse. To get the mouse position & buttons, use <code>vd_fw_get_mouse_state</code> or<code>vd_fw_get_mouse_statef</code>:float mx, my;  vd_fw_get_mouse_statef(&mx, &my);    glUniform4f(glGetUniformLocation(program, rect_color), 1.f, 0.f, 0.f, 1.f);  glUniform2f(glGetUniformLocation(program, rect_size), 40.f, 40.f);  glUniform2f(glGetUniformLocation(program, rect_off), mx, my);  glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);    glUseProgram(0);  glBindVertexArray(0);          "}
,{
"id": 47,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "set-the-drag-area",
"subtitle": "Set the Drag Area",
"contents": "Lets draw a simple window frame using our rectangle renderer:glUniform4f(glGetUniformLocation(program, rect_color), 0.2f, 0.2f, 0.2f, 1.f);  glUniform2f(glGetUniformLocation(program, rect_size), (float)w, 30.f);  glUniform2f(glGetUniformLocation(program, rect_off), 0.f, 0.f);  glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);          In a borderless window, there is no specified non-client area. So to allow the user to drag the windowonly from a specific place, well use <code>vd_fw_set_ncrects</code>.int draggable_rect[4] = {      0,  // left      0,  // top      w,  // right      30, // bottom  };  vd_fw_set_ncrects(draggable_rect, 0, 0);          Et voila!Now, for the 2 last parameters to <code>vd_fw_set_ncrects</code>:<ul><li>count: Number of excluded rects</li><li>rects: Pointer to array of <code>count</code> rects</li></ul>These allow you to set areas inside the drag area, that are not draggable.Lets draw a red close button in our title bar, and if the mouse is over it, darken it:float button_color[4] = {1.0f, 0.0f, 0.0f, 1.0f};  int mouse_inside_close_button =      (mx > ((float)w - 30.f)) &&      (my > (0.f) && my < (30.f));    if (mouse_inside_close_button) {      button_color[0] = 0.7f;          button_color[1] = 0.0f;          button_color[2] = 0.0f;          button_color[3] = 1.0f;      }    glUniform4f(glGetUniformLocation(program, rect_color), button_color[0],                                                           button_color[1],                                                           button_color[2],                                                           button_color[3]);  glUniform2f(glGetUniformLocation(program, rect_size), 30.f, 30.f);  glUniform2f(glGetUniformLocation(program, rect_off), (float)w - 30.f, 0.f);  glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);          As you can see, we can still drag the window even if the mouse is on the button. <br>To fix that, we have to update our call to <code>vd_fw_set_ncrects</code>:int draggable_rect[4] = {      0,  // left      0,  // top      w,  // right      30, // bottom  };    int exclude_rects[1][4] = {      {          w - 30, // left          0,      // top          w,      // right          30,     // bottom      }  };  vd_fw_set_ncrects(draggable_rect, 1, exclude_rects);          The code is straightforward; we exclude the exact position of our red button."}
,{
"id": 48,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "draw-a-cube",
"subtitle": "Draw a Cube",
"contents": "Lets render some 3D geometry.For this, well need separate shaders; if youre following the tutorial in order, here they are:#define VERTEX_SOURCE3D   #version 330 core                                        n   layout (location = 0) in vec3 aPos;                      n   layout (location = 1) in vec2 aTexCoord;                 n                                                            n   out vec2 TexCoord;                                       n                                                            n   uniform mat4 projection;                                 n   uniform mat4 view;                                       n                                                            n   void main()                                              n   {                                                        n       gl_Position = projection * view * vec4(aPos, 1.0f);  n       TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);     n   }                                                        n     #define FRAGMENT_SOURCE3D   #version 330 core                                        n   out vec4 FragColor;                                      n                                                            n   in vec2 TexCoord;                                        n                                                            n   uniform sampler2D texture1;                              n                                                            n   void main()                                              n   {                                                        n       FragColor = texture(texture1, TexCoord);             n   }                                                        n           Well also create a 3d cube, and a checkerboard texture:float vertices3d[] = {      -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,       0.5f, -0.5f, -0.5f,  1.0f, 0.0f,       0.5f,  0.5f, -0.5f,  1.0f, 1.0f,       0.5f,  0.5f, -0.5f,  1.0f, 1.0f,      -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,      -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,       0.5f, -0.5f,  0.5f,  1.0f, 0.0f,       0.5f,  0.5f,  0.5f,  1.0f, 1.0f,       0.5f,  0.5f,  0.5f,  1.0f, 1.0f,      -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,      -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,      -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,      -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,      -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,      -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,      -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,       0.5f,  0.5f, -0.5f,  1.0f, 1.0f,       0.5f, -0.5f, -0.5f,  0.0f, 1.0f,       0.5f, -0.5f, -0.5f,  0.0f, 1.0f,       0.5f, -0.5f,  0.5f,  0.0f, 0.0f,       0.5f,  0.5f,  0.5f,  1.0f, 0.0f,        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,       0.5f, -0.5f, -0.5f,  1.0f, 1.0f,       0.5f, -0.5f,  0.5f,  1.0f, 0.0f,       0.5f, -0.5f,  0.5f,  1.0f, 0.0f,      -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,      -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,       0.5f,  0.5f, -0.5f,  1.0f, 1.0f,       0.5f,  0.5f,  0.5f,  1.0f, 0.0f,       0.5f,  0.5f,  0.5f,  1.0f, 0.0f,      -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,      -0.5f,  0.5f, -0.5f,  0.0f, 1.0f  };    unsigned int VBO3D, VAO3D;  glGenVertexArrays(1, &VAO3D);  glGenBuffers(1, &VBO3D);  glBindVertexArray(VAO3D);  glBindBuffer(GL_ARRAY_BUFFER, VBO3D);  glBufferData(GL_ARRAY_BUFFER, sizeof(vertices3d), vertices3d, GL_STATIC_DRAW);  // position attribute  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);  glEnableVertexAttribArray(0);  // texture coord attribute  glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));  glEnableVertexAttribArray(1);    unsigned int checkerboard[] = {      0xFFFFFFFF, 0xFF000000,      0xFF000000, 0xFFFFFFFF  };    GLuint texture;  glGenTextures(1, &texture);  glBindTexture(GL_TEXTURE_2D, texture);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 2, 2, 0, GL_RGBA, GL_UNSIGNED_BYTE, checkerboard);  glGenerateMipmap(GL_TEXTURE_2D);          Since well be rendering both 3D and 2D, well need to make sure GL_DEPTH_TEST is onlyenabled for the 3D part of our rendering:glDisable(GL_DEPTH_TEST);  glUseProgram(program);  glBindVertexArray(VAO);    float projection[16];  vd_fw_u_ortho(0.f, (float)w, (float)h, 0.f, -1.f, 1.f, projection);  glUniformMatrix4fv(glGetUniformLocation(program, projection), 1, GL_FALSE, projection);  // ... Rest of 2D rendering code    glEnable(GL_DEPTH_TEST);  // 3D rendering code          Before our main loop, were also going to add some variables for the camera:float camera_position[3] = {0.f, 0.f, -2.f};  float camera_yaw   = 0.f;  float camera_pitch = 30.f;  float deg2rad = 3.14159265359f / 180.f;  float camera_speed = 2.f;          Now for rendering the cube depending on camera position & rotation:glEnable(GL_DEPTH_TEST);  float fw = (float)w;  float fh = (float)h;    // Compute forward vector  float camera_forward[3] = {      VD_FW_COS(deg2rad * camera_pitch) * VD_FW_SIN(deg2rad * camera_yaw),      VD_FW_SIN(deg2rad * camera_pitch),      VD_FW_COS(deg2rad * camera_pitch) * VD_FW_COS(deg2rad * camera_yaw)  };    // Normalize forward vector  float camera_forward_len = VD_FW_SQRT(      camera_forward[0] * camera_forward[0] +      camera_forward[1] * camera_forward[1] +      camera_forward[2] * camera_forward[2]);    camera_forward[0] = camera_forward[0] / camera_forward_len;  camera_forward[1] = camera_forward[1] / camera_forward_len;  camera_forward[2] = camera_forward[2] / camera_forward_len;    float camera_ref_up[3] = {0.f, 1.f, 0.f};    // Compute right vector by taking the cross product of foward x up  float camera_right[3] = {      camera_forward[1] * camera_ref_up[2] - camera_forward[2] * camera_ref_up[1],      camera_forward[2] * camera_ref_up[0] - camera_forward[0] * camera_ref_up[2],      camera_forward[0] * camera_ref_up[1] - camera_forward[1] * camera_ref_up[0],  };    // Normalize right vector  float camera_right_len = VD_FW_SQRT(      camera_right[0] * camera_right[0] +      camera_right[1] * camera_right[1] +      camera_right[2] * camera_right[2]);    camera_right[0] = camera_right[0] / camera_right_len;  camera_right[1] = camera_right[1] / camera_right_len;  camera_right[2] = camera_right[2] / camera_right_len;    glViewport(0, 0, w, h - 30);  glUseProgram(program3d);  glBindVertexArray(VAO3D);    float projection[16] = {0.f};  vd_fw_u_perspective(60.f, fw / fh, 0.1f, 100.0f, projection);    float view[16] = {0.f};  float ctar[3] = {      camera_position[0] + camera_forward[0],      camera_position[1] + camera_forward[1],      camera_position[2] + camera_forward[2]};  float cup[3]  = {0.f, 1.f, 0.f};  vd_fw_u_lookat(camera_position, ctar, cup, view);    glActiveTexture(GL_TEXTURE0);  glBindTexture(GL_TEXTURE_2D, texture);    glUseProgram(program3d);  glUniformMatrix4fv(glGetUniformLocation(program3d, projection), 1, GL_FALSE, projection);  glUniformMatrix4fv(glGetUniformLocation(program3d, view), 1, GL_FALSE, view);  glUniform1i(glGetUniformLocation(program3d, texture1), 0);    glBindVertexArray(VAO3D);    glDrawArrays(GL_TRIANGLES, 0, 36);          And here we have a 3d cube! As you can see, Ive already added the movement of the camerafor demonstration purposes, but well have a look at input in the next section."}
,{
"id": 49,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "handle-input",
"subtitle": "Handle Input",
"contents": "Weve already seen some mouse state handling, but lets look at the main functions used forinput:<ul><li><code>vd_fw_delta_s</code>, to get delta time since last frame</li><li><code>vd_fw_get_mouse_state</code>, to read the mouse state</li><li><code>vd_fw_get_mouse_delta</code>, to read how much the mouse moved since last frame</li><li><code>vd_fw_get_key_down</code>, to check if a key is currently down</li><li><code>vd_fw_get_key_pressed</code>, to check if a key was just pressed</li><li><code>vd_fw_set_mouse_locked</code>, to hide and confine the mouse to the window</li></ul>So lets add some camera manipulation, well start by getting the delta time in seconds:float ds = vd_fw_delta_s();          Its also common to lock the mouse and hide it, so lets do that as well at the start of theapplication:vd_fw_set_mouse_locked(1);          Heres also the snippet moving the camera:// Get key states  float fwdir = (float)(vd_fw_get_key_down(W) - vd_fw_get_key_down(S));  float rgdir = (float)(vd_fw_get_key_down(A) - vd_fw_get_key_down(D));  float updir = (float)(vd_fw_get_key_down(Q) - vd_fw_get_key_down(E));    // Compute overall move direction  float camera_move_dir[3] = {      fwdir * camera_forward[0] + rgdir * camera_right[0] + updir * camera_ref_up[0],      fwdir * camera_forward[1] + rgdir * camera_right[1] + updir * camera_ref_up[1],      fwdir * camera_forward[2] + rgdir * camera_right[2] + updir * camera_ref_up[2],  };    // Normalize move direction, if its length is not too small (i.e. were not pressing any keys)  float camera_dir_lensq =       camera_move_dir[0] * camera_move_dir[0] +      camera_move_dir[1] * camera_move_dir[1] +      camera_move_dir[2] * camera_move_dir[2];    if (camera_dir_lensq > 0.0001f) {      // Normalize move direction and apply it to the cameras position      float camera_move_dir_len = VD_FW_SQRT(camera_dir_lensq);        camera_move_dir[0] = camera_move_dir[0] / camera_move_dir_len;      camera_move_dir[1] = camera_move_dir[1] / camera_move_dir_len;      camera_move_dir[2] = camera_move_dir[2] / camera_move_dir_len;        camera_position[0] += camera_move_dir[0] * camera_speed * ds;      camera_position[1] += camera_move_dir[1] * camera_speed * ds;      camera_position[2] += camera_move_dir[2] * camera_speed * ds;  }          Finally, inside of our rendering loop, we compute the cameras pitch and yaw based on the mouse delta:if (vd_fw_get_mouse_locked()) {      float mouse_delta_x, mouse_delta_y;      vd_fw_get_mouse_delta(&mouse_delta_x, &mouse_delta_y);        camera_yaw   += mouse_delta_x;      camera_pitch -= mouse_delta_y;  };    if (camera_pitch < -89.9f) camera_pitch = -89.9f;  if (camera_pitch > +89.9f) camera_pitch = +89.9f;    if (camera_yaw > +360.f) camera_yaw -= 360.f;  if (camera_yaw < -360.f) camera_yaw += 360.f;    float camera_forward[3] = {      VD_FW_COS(deg2rad * camera_pitch) * VD_FW_SIN(deg2rad * camera_yaw),      // ..          Okay, we can move the cube, but we cant really exit the application easily, since the mouseis confined. Lets make Shift + F1 unlock the mouse:if (vd_fw_get_key_pressed(VD_FW_KEY_F1) && vd_fw_get_key_down(VD_FW_KEY_LSHIFT)) {      vd_fw_set_mouse_locked(!vd_fw_get_mouse_locked());  }          And we finally have a resizable, draggable window with our own custom button and cube."}
,{
"id": 50,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "set-the-window-icon",
"subtitle": "Set the Window Icon",
"contents": "To set the window icon, call:// Image format must be in ARGB little-endian (i.e 0xAARRGGBB)  vd_fw_set_app_icon(pixels, width, height);          If youre following along with the tutorial, we will temporarily change the window to havedecorations, so that we can see the icon drawn by Windows in the caption:vd_fw_init(& (VdFwInitInfo) {      .gl = {          .version = VD_FW_GL_VERSION_3_3,          .debug_on = 0,      },      .window_options = {          .borderless = 0, // <---      }  });          Lets draw a simple red-ish gradient from top to bottom, and set that as our icon:unsigned int icon_pixels[32*32];  for (int y = 0; y < 32; ++y) {      for (int x = 0; x < 32; ++x) {            float t = ((float)(y * 32 + x)) / (32.f * 32.f);            t = (VD_FW_SIN(t * 2) + 1.0f) * 0.5f;            float r = 0.7f * t;          float g = 0.2f * t;          float b = 0.0f * t;            icon_pixels[y * 32 + x] = 0xFF << 24                       |                                    ((unsigned char)(r * 255)) << 16 |                                    ((unsigned char)(g * 255)) <<  8 |                                    ((unsigned char)(b * 255)) <<  0;      }  }  vd_fw_set_app_icon(icon_pixels, 32, 32);          On Windows, the icon will also be shown in:<ul><li>The App Bar (Taskbar), and</li><li>The Window switcher (Alt + Tab)</li></ul>"}
,{
"id": 51,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "use-the-discrete-gpu",
"subtitle": "Use the Discrete GPU",
"contents": "The OpenGL specification makes no distinction between the presence of multiple GPUs insidethe target system; one will be automatically selected based on vendor preference settingshost OS, and other factors that the developer will not be able to affect.However, for most systems there is a way to tell the OS at least what <i>kind</i> of GPUthe application prefers. This library can be instructed to do that through using:#define VD_FW_PREFER_DISCRETE_GPU    // Prefer D-GPU  // Or  #define VD_FW_PREFER_INTEGRATED_GPU  // Prefer I-GPU (The one inside your CPU)          Of course, this doesnt mean that your target application will only use the GPU type youspecified, but it will signal to whatever system decides this that the application prefersthat type of GPU.There are many more technicalities, the most important of which to know is: The OpenGLbackend will change/swap GPUs if run on an Optimus, or other kind of laptop that featuresGPU switching. It will also change (depending on the operating system, version, etc.), ifthe window enters a full-screen state. Most of these 2 GPU devices are high end gaming laptops, which use the integrated GPU forlow priority tasks, such as the web browser, and keep the discrete GPU turned off until ademanding task, like a game needs it. My suggestion is:<ul><li>For GUI applications:<br> <b>Dont set any GPU preference</b>. These apps are supposed to use few systemresources anyway. This will guarantee that resizing, going fullscreen, etc.. willmatch the display context to the currently used one by other applications.</li><li>For games:<br><b>Always use the discrete GPU</b>, since those are the ones that implement the mostOpenGL extensions, as well as the fastest ones. But be aware that initial startuptime (especially on gaming laptops with 2 GPUs), will be affected.        </li></ul>"}
,{
"id": 52,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "reference",
"subtitle": "Reference",
"contents": ""}
,{
"id": 53,
"page": "vd_fw.html",
"title": "vd_fw",
"section": "input-mappings",
"subtitle": "Input Mappings",
"contents": "This is a complete list of all possible input mappings supported by this library.Alternatively, click below to open an interactive interface:Open Input MappingsHeres all the mapped keybindings. For most of them, considerations were taken to map the values to ASCIIsymbols that correspond to the physical key on a US ANSI/ISO keyboard layout.enum {      VD_FW_KEY_UNKNOWN       = 0,      VD_FW_KEY_F1            = 1,      VD_FW_KEY_F2            = 2,      VD_FW_KEY_F3            = 3,      VD_FW_KEY_F4            = 4,      VD_FW_KEY_F5            = 5,      VD_FW_KEY_F6            = 6,      VD_FW_KEY_F7            = 7,      VD_FW_KEY_F8            = 8,      VD_FW_KEY_F9            = 9,      VD_FW_KEY_F10           = 10,      VD_FW_KEY_F11           = 11,      VD_FW_KEY_F12           = 12,      VD_FW_KEY_F13           = 13,      VD_FW_KEY_F14           = 14,      VD_FW_KEY_F15           = 15,      VD_FW_KEY_F16           = 16,      VD_FW_KEY_F17           = 17,      VD_FW_KEY_F18           = 18,      VD_FW_KEY_F19           = 19,      VD_FW_KEY_F20           = 20,      VD_FW_KEY_F21           = 21,      VD_FW_KEY_F22           = 22,      VD_FW_KEY_F23           = 23,      VD_FW_KEY_F24           = 24,      VD_FW_KEY_BACKSPACE     = 25,        VD_FW_KEY_INS           = 26,      VD_FW_KEY_HOME          = 27,      VD_FW_KEY_PGUP          = 28,      VD_FW_KEY_DEL           = 29,      VD_FW_KEY_END           = 30,      VD_FW_KEY_PGDN          = 31,      VD_FW_KEY_SPACE         = 32,  //         VD_FW_KEY_LCONTROL      = 33,      VD_FW_KEY_RCONTROL      = 34,      VD_FW_KEY_LALT          = 35,      VD_FW_KEY_RALT          = 36,      VD_FW_KEY_LSHIFT        = 37,      VD_FW_KEY_RSHIFT        = 38,      VD_FW_KEY_QUOTE         = 39,  //       VD_FW_KEY_ARROW_UP      = 40,      VD_FW_KEY_ARROW_LEFT    = 41,      VD_FW_KEY_ARROW_DOWN    = 42,      VD_FW_KEY_ARROW_RIGHT   = 43,      VD_FW_KEY_COMMA         = 44,  // ,      VD_FW_KEY_MINUS         = 45,  // -      VD_FW_KEY_DOT           = 46,  // .      VD_FW_KEY_SLASH_FORWARD = 47,  // /      VD_FW_KEY_0             = 48,  // 0      VD_FW_KEY_1             = 49,  // 1      VD_FW_KEY_2             = 50,  // 2      VD_FW_KEY_3             = 51,  // 3      VD_FW_KEY_4             = 52,  // 4      VD_FW_KEY_5             = 53,  // 5      VD_FW_KEY_6             = 54,  // 6      VD_FW_KEY_7             = 55,  // 7      VD_FW_KEY_8             = 56,  // 8      VD_FW_KEY_9             = 57,  // 9      VD_FW_KEY_ENTER         = 58,      VD_FW_KEY_SEMICOLON     = 59,  // ;      VD_FW_KEY_TAB           = 60,      VD_FW_KEY_EQUALS        = 61,  // =      VD_FW_KEY_CAPITAL       = 62,      VD_FW_KEY_ESCAPE        = 63,      VD_FW_KEY_RESERVED1     = 64,  // @      VD_FW_KEY_A             = 65,  // A      VD_FW_KEY_B             = 66,  // B      VD_FW_KEY_C             = 67,  // C      VD_FW_KEY_D             = 68,  // D      VD_FW_KEY_E             = 69,  // E      VD_FW_KEY_F             = 70,  // F      VD_FW_KEY_G             = 71,  // G      VD_FW_KEY_H             = 72,  // H      VD_FW_KEY_I             = 73,  // I      VD_FW_KEY_J             = 74,  // J      VD_FW_KEY_K             = 75,  // K      VD_FW_KEY_L             = 76,  // L      VD_FW_KEY_M             = 77,  // M      VD_FW_KEY_N             = 78,  // N      VD_FW_KEY_O             = 79,  // O      VD_FW_KEY_P             = 80,  // P      VD_FW_KEY_Q             = 81,  // Q      VD_FW_KEY_R             = 82,  // R      VD_FW_KEY_S             = 83,  // S      VD_FW_KEY_T             = 84,  // T      VD_FW_KEY_U             = 85,  // U      VD_FW_KEY_V             = 86,  // V      VD_FW_KEY_W             = 87,  // W      VD_FW_KEY_X             = 88,  // X      VD_FW_KEY_Y             = 89,  // Y      VD_FW_KEY_Z             = 90,  // Z      VD_FW_KEY_BRACKET_OPEN  = 91,  // [      VD_FW_KEY_SLASH_BACK    = 92,  //       VD_FW_KEY_BRACKET_CLOSE = 93,  // ]      VD_FW_KEY_MEDIA_NEXT    = 94,  // Media Next Track      VD_FW_KEY_MEDIA_PREV    = 95,  // Media Prev Track      VD_FW_KEY_BACKTICK      = 96,  // `      VD_FW_KEY_MEDIA_PLAY    = 97,  // Media Play/Pause      VD_FW_KEY_NUMPAD_0      = 98,  // Numpad 0      VD_FW_KEY_NUMPAD_1      = 99,  // Numpad 1      VD_FW_KEY_NUMPAD_2      = 100, // Numpad 2      VD_FW_KEY_NUMPAD_3      = 101, // Numpad 3      VD_FW_KEY_NUMPAD_4      = 102, // Numpad 4      VD_FW_KEY_NUMPAD_5      = 103, // Numpad 5      VD_FW_KEY_NUMPAD_6      = 104, // Numpad 6      VD_FW_KEY_NUMPAD_7      = 105, // Numpad 7      VD_FW_KEY_NUMPAD_8      = 106, // Numpad 8      VD_FW_KEY_NUMPAD_9      = 107, // Numpad 9      VD_FW_KEY_MAX,  };          "}
]
