<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
    <head>
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>VD Libs - vd_fw.h</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
        <link rel="stylesheet" href="/style.css">
    </head>
    <body data-bs-spy="scroll" data-bs-target="#toc" data-bs-offset="50" tabindex="0">
        <!-- Begin Navbar -->
        <nav id="mainnav" class="navbar sticky-top navbar-expand-md bg-body-tertiary">
            <div class="container-fluid bg-body-tertiary">
                <a class="navbar-brand" href="/index.html">
                    <img    src="/assets/vd-logo-p@1x.png"
                         srcset="/assets/vd-logo-p@1x.png 1x, /assets/vd-logo-p@2x.png 2x"
                            alt="Brand"
                          width="64"
                         height="38.5">
                </a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" 
                        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav">
                        <li class="nav-item">
                            <a class="nav-link" aria-current="page" href="/index.html">Home</a>
                        </li>
                        <!-- Begin Files -->
                        <li class="nav-item dropdown">
                            <a class="nav-link active dropdown-toggle" href="#" id="documentationDropdown" role="button" 
                               data-bs-toggle="dropdown" aria-expanded="false">
                                Documentation
                            </a>
                            <ul class="dropdown-menu" aria-labelledby="documentationDropdown">
                                <li><a class="dropdown-item"        href="/vd/index.html"   >vd.h</a></li>
                                <li><a class="dropdown-item active" href="/vd_fw/index.html">vd_fw.h</a></li>
                            </ul>
                        </li>
                        <!--   End Files -->
                    </ul>

                </div>
            </div>
        </nav>
        <!--   End Navbar -->


        <!-- Begin Content -->
        <div class="container">
            <div class="row flexijustify ">
                <div id="main-content" class="col-12 col-sm-12 flexijustify-midpoint col-md-8 col-lg-6 col-xl-7 text-start mx-auto mx-lg-4" style="margin-top: 0px;">

                    <nav id="toc" data-toc class="toc-outline d-none midpoint-flex flexijustify-grow p-0 nav outline-section flex-column">
                        
                    </nav>

                    <!-- <nav id="toc" class="toc-outline d-none d-lg-flex p-0 nav outline-section flex-column">
                        <a class="nav-link" href="#brief">Brief</a>
                        <a class="nav-link" href="#linking">Linking & Dependencies</a>
                        <div class="nav outline-section flex-column ms-3">
                            <a class="nav-link" href="#linking-windows">Windows</a>
                            <a class="nav-link" href="#linking-macos">MacOS</a>
                        </div>
                        <a class="nav-link" href="#support">Support</a>
                        <div class="nav outline-section flex-column ms-3">
                            <a class="nav-link" href="#platforms">Platforms</a>
                            <a class="nav-link" href="#revisions">Revisions</a>
                        </div>
                        <a class="nav-link" href="#tutorials">Tutorials</a>
                        <div class="nav outline-section flex-column ms-3">
                            <a class="nav-link" href="#tutorials-main-loop">Main Loop</a>
                            <a class="nav-link" href="#tutorials-choose-version">Choose OpenGL Version</a>
                            <a class="nav-link" href="#tutorials-borderless-window">Create a Borderless Window</a>
                            <a class="nav-link" href="#tutorials-compiling-shaders">Create a Shader Program</a>
                            <a class="nav-link" href="#tutorials-creating-vertex-buffer">Draw a Rectangle</a>
                            <a class="nav-link" href="#tutorials-ncrects">Set the Drag Area</a>
                            <a class="nav-link" href="#tutorials-rendering-3d">Render 3D</a>
                            <a class="nav-link" href="#tutorials-input">Input</a>
                        </div>
                        <a class="nav-link" href="#api-ref">Reference</a>
                    </nav> -->

                    <section class="L1 section" id="brief">
                        <h4 id="brief">Brief</h4>
                        <hr>

                        <img    src="/assets/fw/vd-fw-logo@1x.png"
                             srcset="/assets/fw/vd-fw-logo@1x.png 1x, /assets/fw/vd-fw-logo@2x.png 2x"
                              width="128"
                             height="106.5"
                             class="span-image">
                        <p>
                            A library that gets you a semi-customizable window and an OpenGL context, minimizing 
                            dependencies and hiding the complexities of doing proper windowing on each platform.
                        </p>

                        <p>
                            It's written with performance in mind; though performance is not the main focus of it.
                            <b>Maintainability</b>, <b>support</b> for the defined feature set and <b>ease of use</b>
                            are the primary targets of this library.
                        </p>

                        <p>
                            <b>Why should you use this library over, GLFW, SDL, SFML, ...?</b>
                            <br>

                            Those libraries solve a <b>much more</b> general problem than the one most developers have:
                            <ul>
                                <li>Create one or more windows</li>
                                <li>Enable/disable window styling</li>
                                <li>Handle child/parent window relationships</li>
                                <li>Provide aliases for common usermode operations (show file dialog, message box)</li>
                                <li>Support many more platforms, even ones that don't include a windowing system.</li>
                                <li>Support multiple graphics APIs for initialization.</li>
                                <li>Provide a high level drawing interface.</li>
                                <li>Provide a high level sound interface.</li>
                                <li>Allow for entirely customized windows.</li>
                                <li>And much more...</li>
                            </ul>

                            But in their attempt to be "generic" and "robust", they fail to provide a good and simple
                            interface that covers 90% of the use cases, and is implemented in the best way possible for
                            each platform.
                        </p>

                        <p>
                            One common example is that almost every popular windowing library on Windows does not allow
                            the developer to draw while resizing or moving the window.

                            This is an introcacy of the Win32 API (and actually the same is true for MacOS), and the
                            recommended way is not exactly obvious to a new developer, or one unfamiliar with the
                            platform.
                            <br>
                        </p>

                        <p>
                            Another gripe I have with these libraries is that for OpenGL you are <b>required</b> to
                            either bring in your own loader, or use an off the shelf one, even though when someone is
                            only starting to learn graphics programming, they don't know the difference between "Core
                            Profile", "Compatibility Profile", or even what an extension is.
                        </p>

                        <div class="alert alert-primary d-flex align-items-center" role="alert">
                            <div>
                                Note that you don't need to use an OpenGL loader or include any OS specific OpenGL
                                libraries.
                                <br>
                                The library does the loading for you.
                            </div>
                        </div>

                        <p>
                            Here is all you need (and should need) to create a simple window.
                            <br>
                            By default it creates an OpenGL 3.3 core profile context:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
#include "vd_fw.h"                                           // Include library
int main() {
    vd_fw_init(NULL);                                        // Initialize library
    while (vd_fw_running()) {                                // Check if the window is closed & gather events
        glClearColor(0.5f, 0.3f, 0.2f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        vd_fw_swap_buffers();                                // Swap buffers
    }
    return 0;
}

#define VD_FW_IMPL                                           // Include implementation code
#include "vd_fw.h"
                        </code></pre>

                        <div id="fw-window-simple" class="rounded carousel slide">
                            <div class="carousel-inner">
                               <div class="carousel-item active">
                                    <img class="img-fluid" src="/assets/fw/window-simple-win32.png">
                               </div> 
                               <div class="carousel-item">
                                    <img class="img-fluid" src="/assets/fw/window-simple-macos.png">
                               </div> 
                            </div>
                            <button class="carousel-control-prev" type="button" data-bs-target="#fw-window-simple" data-bs-slide="prev">
                                <span class="carousel-control-prev-icon" style="filter: invert(1) grayscale(100%) brightness(200%);" aria-hidden="true"></span>

                                <span class="visually-hidden">Previous</span>
                            </button>
                            <button class="carousel-control-next" type="button" data-bs-target="#fw-window-simple" data-bs-slide="next">
                                <span class="carousel-control-next-icon" style="filter: invert(1) grayscale(100%) brightness(200%);" aria-hidden="true"></span>
                                <span class="visually-hidden">Next</span>
                            </button>
                        </div>
                    </section>
                    <br>

                    <section class="L1 section" id="linking">
                        <h4>Linking & Dependencies</h4>
                        <hr>

                        <p>
                            This library is distributed as a single, header-only file, thus the following instructions
                            are meant to be considered for your final application/dynamic library.
                            <br> <br>

                            In general, I make use of the up-to-date platform specific APIs, that should be available
                            with every distribution of said platform's development environment.
                            <br> <br>

                            Some preprocessor directives to set depending on your needs:

                        </p>

                        <table class="table">
                            <tr>
                                <th scope="col">Option</th>
                                <th scope="col">Description</th>
                            </tr>
                            <tbody>
                                <tr>
                                    <td><code>VD_FW_VERSION_MAJOR</code></td>
                                    <td>Major version number of the library</td>
                                </tr>
                                <tr>
                                    <td><code>VD_FW_VERSION_MINOR</code></td>
                                    <td>Minor version number of the library</td>
                                </tr>
                                <tr>
                                    <td><code>VD_FW_VERSION_PATCH</code></td>
                                    <td>Patch version number of the library</td>
                                </tr>
                                <tr>
                                    <td><code>VD_FW_VERSION</code></td>
                                    <td>Combined version (major, minor, patch) number of the library</td>
                                </tr>
                                <tr>
                                    <td><code>#define VD_FW_STATIC</code></td>
                                    <td>Set to use this library statically.</td>
                                </tr>
                                <tr>
                                    <td><code>#define VD_FW_API // (static, extern, ...dllexport)</code></td>
                                    <td>Set to change the function signature (useful for precompiling the library).</td>
                                </tr>
                                <tr>
                                    <td><code>#define VD_FW_INL</code></td>
                                    <td>Set to change inlined functions' signatures.</td>
                                </tr>
                                <tr>
                                    <td><code>#define VD_FW_NO_CRT</code></td>
                                    <td>
                                        Options:
                                        <ul>
                                            <li>Set to '1' to disable including C standard library</li>
                                            <li>Set to '0' to enable including C standard library</li>
                                        </ul>
                                    </td>
                                </tr>
                                <tr>
                                    <td><code>#define VD_FW_SIN</code></td>
                                    <td>
                                        Options:
                                        <ul>
                                            <li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>sinf</code></li>
                                            <li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_sin (custom implementation).</li>
                                        </ul>
                                    </td>
                                </tr>
                                <tr>
                                    <td><code>#define VD_FW_COS</code></td>
                                    <td>
                                        Options:
                                        <ul>
                                            <li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>cosf</code></li>
                                            <li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_cos (custom implementation).</li>
                                        </ul>
                                    </td>
                                </tr>
                                <tr>
                                    <td><code>#define VD_FW_TAN</code></td>
                                    <td>
                                        Options:
                                        <ul>
                                            <li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>tanf</code></li>
                                            <li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_tan (custom implementation).</li>
                                        </ul>
                                    </td>
                                </tr>
                                <tr>
                                    <td><code>#define VD_FW_SQRT</code></td>
                                    <td>
                                        Options:
                                        <ul>
                                            <li>If <code>VD_FW_NO_CRT == 1</code> it's resolved to libc <code>sqrtf</code></li>
                                            <li>If <code>VD_FW_NO_CRT == 0</code> it's resolved to vd_fw_sqrt (custom implementation).</li>
                                        </ul>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <code>#define VD_FW_WIN32_SUBSYSTEM</code><br>
                                        <code>// Can be one of the following:</code><br>
                                        <code>// VD_FW_WIN32_SUBSYSTEM_CONSOLE</code><br>
                                        <code>// VD_FW_WIN32_SUBSYSTEM_WINDOWS</code>
                                    </td>
                                    <td>Change the <a href="https://learn.microsoft.com/en-us/cpp/build/reference/subsystem-specify-subsystem?view=msvc-170">Subsystem</a> (Windows only).</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <br>


                    <section class="L2 section" id="linking-windows">
                        <h4>Windows</h4>
                        <p>
                            With MSVC you don't really need to link anything, since linker directives in the
                            translation unit that includes vd_fw.h are defined, so that the appropriate libraries
                            and subsystem are used. But for reference, here they are:
                        </p>
                        <ol class="list-group">
                            <li class="list-group-item">User32</li>
                            <li class="list-group-item">OpenGL32</li>
                            <li class="list-group-item">Dwmapi</li>
                            <li class="list-group-item">Shcore</li>
                            <li class="list-group-item">Gdi32</li>
                            <li class="list-group-item">uxtheme</li>
                            <li class="list-group-item">shell32</li>
                            <li class="list-group-item">kernel32</li>
                            <li class="list-group-item">winmm</li>
                        </ol>
                        <br>
                        <p>
                            To set the subsystem of the application: 
                            <ul>
                                <li> Windows: <code>#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_WINDOWS</code> </li>
                                <li> Console: <code>#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_CONSOLE</code> </li>
                            </ul>
                        </p>

                        <p>
                            If you're on the Windows subsystem, but would still like a console for debugging purposes, this
                            can be done by setting <code>VdFwInitInfo::gl_options::debug_on = 1</code> when calling
                            <code>vd_fw_init</code>.

                            <br>
                            This will allocate a console and set-up the relevant gl debug callback for you.
                        </p>

                        <p>
                            It's highly recommended to <code>#define VD_FW_NO_CRT 1</code> so that the CRT is removed
                            when linking. This can reduce the final executable size by a factor of 10 (for small applications).
                        </p>
                    </section>

                    <section class="L2 section" id="linking-macos">
                        <h4>MacOS</h4>
                        <p>
                            For MacOS, it's a bit different. with clang, you must link several frameworks (via <code>-framework framework_name</code>).
                            Additionally, <code>-x objective-c</code> must be used since the Mac APIs use Objective-C.
                        </p>
                        <ol class="list-group">
                            <li class="list-group-item">pthread (compiler flag)</li>
                            <li class="list-group-item">Cocoa</li>
                            <li class="list-group-item">Metal</li>
                            <li class="list-group-item">QuartzCore</li>
                            <li class="list-group-item">CoreGraphics</li>
                            <li class="list-group-item">IOSurface</li>
                            <li class="list-group-item">IOKit</li>
                            <li class="list-group-item">Foundation</li>
                            <li class="list-group-item">OpenGL</li>
                        </ol>
                        <br>
                    </section>
                    <br>

                    <section class="L1 section" id="support">
                        <h4>Support</h4>
                        <hr>

                        <pre class="rounded copy"><code class="language-txt">
zlib License

(C) Copyright 2025-2026 Michael Dodis (michaeldodisgr@gmail.com)
 This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
                        </code></pre>

                        <p>
                            As stated in the license, no warranty or guarantee is provided by the use of this software library.    
                        </p>

                        <p>
                            That being said, I will look at issues when I have the time, and/or if they are important to the core
                            principles of this library.
                        </p>

                        <p><a class="link-opacity-100" href="https://github.com/mdodis/vd-libs/issues/new">Submit issues here</a></p>
                    </section>

                    <section class="L2 section" id="platforms">
                        <h4>Platforms</h4>
                        <p>
                            Due to platform limitations, platform-specific APIs and frameworks, vd_fw.h will
                            never have support for some platforms. One example is Android, where Java is required.
                        </p>
                        <p>
                            Though, I'm still thinking about how this can be done easily, so I will leave the possibility
                            open.
                        </p>
                        <table class="table">
                            <tr>
                                <th scope="col">Platform</th>
                                <th scope="col">Supported</th>
                            </tr>
                            <tbody>
                                <tr>
                                    <td>Windows</td>
                                    <td class="table-success">Yes</td>
                                </tr>
                                <tr>
                                    <td>MacOS</td>
                                    <td class="table-warning">In Progress</td>
                                </tr>
                                <tr>
                                    <td>Linux (X11)</td>
                                    <td>Coming soon...</td>
                                </tr>
                                <tr>
                                    <td>Linux (Wayland)</td>
                                    <td>Not Planned</td>
                                </tr>
                                <tr>
                                    <td>iOS</td>
                                    <td>Not Planned</td>
                                </tr>
                                <tr>
                                    <td>Android</td>
                                    <td>Not Planned</td>
                                </tr>
                                <tr>
                                    <td>Web</td>
                                    <td>Not Planned</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>

                    <section class="L2 section" id="revisions">
                        <h4>Revisions</h4> 
                        <div class="list-group">
                            <a class="list-group-item">
                                <div class="d-flex w-100 justify-content-between">
                                    <h5 class="mb-1">1.0.0</h5>
                                    <small class="text-body-secondary">xx/xx/xxxx</small>
                                </div>
                                <p class="mb-1">
                                    Initial Release:
                                    <ul>
                                        <li>Full Win32 support</li>
                                        <li>Partial MacOS support</li>
                                    </ul>
                                </p>
                            </a>
                        </div>

                    </section>
                    <br>

                    <section class="L1 section" id="tutorials">
                        <h4>Tutorials</h4>
                        <hr>
                        <p>
                            A collection of tutorials for how to use the library.
                        </p>

                        <p>
                            These do not show proper code, nor do they show correct OpenGL API usage, but they show various
                            features of vd_fw.h
                        </p>

                        <p>
                            We will start by creating a simple window, and continue with:
                            <ul>
                                <li>Making it borderless</li>
                                <li>Drawing a rectangle</li>
                                <li>Setting the drag area</li>
                                <li>Drawing some 3D geometry</li>
                                <li>Handling input in a user-friendly way</li>
                            </ul>

                            You can safely read each tutorial on its own, or in order. It will guide you through
                            almost all of the parts of the API
                        </p>

                        <p>
                            Additionally, several samples are available <a href="https://github.com/mdodis/vd-libs/tree/main/samples">here</a>,
                            which map to several parts of the tutorial.
                        </p>

                        <p>
                            This tutorial is written in C, but you can safely use C++ with it
                        </p>
                    </section>
                    <br>


                    <section class="L2 section" id="tutorials-main-loop">
                        <h4>Main Loop</h4>
                        <p>
                            Let's look at the main loop.
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
#define VD_FW_NO_CRT 0                                       // Disable CRT, this is highly recommended,
                                                             // if you know what you're doing.
#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_WINDOWS  // Disable console (Windows)
#include "vd_fw.h"

int main(int argc, char const *argv[])
{
    vd_fw_init(NULL);                                        // Initialize library
    vd_fw_set_vsync_on(1);                                   // Enable VSYNC

    while (vd_fw_running()) {                                // Check if user closed the window

        int w, h;
        vd_fw_get_size(&w, &h);                              // Get window size, in pixels.

        glViewport(0, 0, w, h);                              // Setup viewport
        glClearColor(0.5f, 0.3f, 0.2f, 1.0f);                // Select clear color
        glClear(GL_COLOR_BUFFER_BIT);                        // Clear

        vd_fw_swap_buffers();                                // Swap buffers
    }

    return 0;
}

#define VD_FW_IMPL                                           // Include implementation
#include "vd_fw.h"
                        </code></pre>
                        <br>

                        <p>
                            This will create a window, that can be moved and resized.
                        </p>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-main-loop.gif">
                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-choose-version">
                        <h4>Choose OpenGL Version</h4>
                        <p>
                            To specify the OpenGL version, create a <code>VdFwInitInfo</code> struct, populate the
                            <code>VdFwInitInfo::gl::version</code> member, and pass it to <code>vd_fw_init</code>.
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
VdFwInitInfo init_info = {};
init_info.gl.version = VD_FW_GL_VERSION_4_5; // Set OpenGL Version
vd_fw_init(&init_info);
                        </code></pre>

                        <p>
                            For reference, here's all of the possible versions:
                        </p>

                        <pre class="rounded"><code class="language-cpp">
typedef enum {
    VD_FW_GL_VERSION_BASIC = 0,
    VD_FW_GL_VERSION_1_0   = 1,
    VD_FW_GL_VERSION_1_2   = 12,
    VD_FW_GL_VERSION_1_3   = 13,
    VD_FW_GL_VERSION_1_4   = 14,
    VD_FW_GL_VERSION_1_5   = 15,
    VD_FW_GL_VERSION_2_0   = 20,
    VD_FW_GL_VERSION_2_1   = 21,
    VD_FW_GL_VERSION_3_0   = 30,
    VD_FW_GL_VERSION_3_1   = 31,
    VD_FW_GL_VERSION_3_2   = 32,
    VD_FW_GL_VERSION_3_3   = 33,
    VD_FW_GL_VERSION_4_0   = 40,
    VD_FW_GL_VERSION_4_1   = 41,
    VD_FW_GL_VERSION_4_2   = 42,
    VD_FW_GL_VERSION_4_3   = 43,
    VD_FW_GL_VERSION_4_4   = 44,
    VD_FW_GL_VERSION_4_5   = 45,
    VD_FW_GL_VERSION_4_6   = 46,
} VdFwGlVersion;
                        </code></pre>

                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-borderless-window">
                        <h4>Create a Borderless Window</h4>
                        <p>
                            To create a borderless window, create a <code>VdFwInitInfo</code> struct, set
                            <code>VdFwInitInfo::window_options::borderless</code> to 1, and pass it to <code>vd_fw_init</code>.
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
VdFwInitInfo init_info = {};
init_info.window_options.borderless = 1;
vd_fw_init(&init_info);
                        </code></pre>
                        <br>

                        <p>
                            This will create a borderless window, that can be moved (by dragging any part of the window), and resized.
                        </p>
                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-borderless.gif">
                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-compiling-shaders">
                        <h4>Create a Shader Program</h4>
                        <p>
                            Let's create a simple 2D rectangle application.
                            <br>

                            We'll create some in-source shaders, and compile them, as we would in any OpenGL application.
                            If you'd like to follow along, here are the shaders we'll be using:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
#define VERTEX_SOURCE \
"#version 330 core                                                                                                 \n" \
"layout (location = 0) in vec2 aPos;                                                                               \n" \
"                                                                                                                  \n" \
"uniform vec2 rect_off;                                                                                            \n" \
"uniform vec2 rect_size;                                                                                           \n" \
"uniform mat4 projection;                                                                                          \n" \
"                                                                                                                  \n" \
"                                                                                                                  \n" \
"void main()                                                                                                       \n" \
"{                                                                                                                 \n" \
"    gl_Position = projection * vec4(aPos * rect_size + rect_off, 0.0, 1.0f);                                      \n" \
"}                                                                                                                 \n" \

#define FRAGMENT_SOURCE \
"#version 330 core                                                                                                 \n" \
"out vec4 FragColor;                                                                                               \n" \
"                                                                                                                  \n" \
"uniform vec4 rect_color;                                                                                          \n" \
"                                                                                                                  \n" \
"void main()                                                                                                       \n" \
"{                                                                                                                 \n" \
"    FragColor = rect_color;                                                                                       \n" \
"}                                                                                                                 \n" \
                        </code></pre>
                        <br>

                        <p>
                            And the typical OpenGL shader compilation code:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
const char *vertex_shader_source = VERTEX_SOURCE;
const char *fragment_shader_source = FRAGMENT_SOURCE;

// Compile shaders
GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vertex_shader, 1, &vertex_shader_source, 0);
glCompileShader(vertex_shader);

GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragment_shader, 1, &fragment_shader_source, 0);
glCompileShader(fragment_shader);

GLuint program = glCreateProgram();
glAttachShader(program, vertex_shader);
glAttachShader(program, fragment_shader);
glLinkProgram(program);
                        </code></pre>

                        <p>
                            In most tutorials, you'll be prompted to do error checking by doing <code>glGetShaderiv</code>,
                            then <code>glGetShaderInfoLog</code> and printing it out...
                            <br>

                            This library provides a convenience function (and more) to do that, and will also log the errors:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
GLuint vertex_shader   = vd_fw_compile_shader(GL_VERTEX_SHADER,   VERTEX_SOURCE);
GLuint fragment_shader = vd_fw_compile_shader(GL_FRAGMENT_SHADER, FRAGMENT_SOURCE);
                        </code></pre>

                        <p>
                            For error logging, make sure to set <code>VdFwInitInfo::gl::debug_on</code> to 1 when initializing the library.
                            Here's the <code>vd_fw_init</code> call we'll be using for the rest of these tutorials:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
vd_fw_init(& (VdFwInitInfo) {
    .gl = {
        .version = VD_FW_GL_VERSION_3_3,
        .debug_on = 1,
    },
    .window_options = {
        .borderless = 1,
    }
});
                        </code></pre>

                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-creating-vertex-buffer">
                        <h4>Draw a Rectangle</h4>
                        <p>
                            Continuing from the previous section, we create a vertex buffer for a 2d rectangle:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
float rect_vertices[] = {
     0.0f,  0.0f,
    +1.0f,  0.0f,
     0.0f, +1.0f,
    +1.0f, +1.0f
};

unsigned int VBO, VAO;
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);
glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(rect_vertices), rect_vertices, GL_STATIC_DRAW);
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
                        </code></pre>
                        <br>

                        <p>
                            And now for drawing a rectangle.
                            <br>

                            We'll use orthographic projection. vd_fw.h provides a simple utility function to compute it:
                            <code>vd_fw_u_ortho</code>
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
glUseProgram(program);
glBindVertexArray(VAO);

{
    float projection[16];
    vd_fw_u_ortho(0.f, (float)w, (float)h, 0.f, -1.f, 1.f, projection);
    glUniformMatrix4fv(glGetUniformLocation(program, "projection"), 1, GL_FALSE, projection);
}
                        </code></pre>
                        <br>

                        <p>
                            To test that the coordinate transformation is working, we'll map the top left of the rectangle
                            to the mouse. To get the mouse position & buttons, use <code>vd_fw_get_mouse_state</code> or <code>vd_fw_get_mouse_statef</code>:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
float mx, my;
vd_fw_get_mouse_statef(&mx, &my);

glUniform4f(glGetUniformLocation(program, "rect_color"), 1.f, 0.f, 0.f, 1.f);
glUniform2f(glGetUniformLocation(program, "rect_size"), 40.f, 40.f);
glUniform2f(glGetUniformLocation(program, "rect_off"), mx, my);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

glUseProgram(0);
glBindVertexArray(0);
                        </code></pre>
                        <br>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-drawing-a-rectangle.gif">

                    </section> 
                    <br>


                    <section class="L2 section" id="tutorials-ncrects">
                        <h4>Set the Drag Area</h4>
                        <p>
                            Let's draw a simple window frame using our rectangle "renderer":
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
glUniform4f(glGetUniformLocation(program, "rect_color"), 0.2f, 0.2f, 0.2f, 1.f);
glUniform2f(glGetUniformLocation(program, "rect_size"), (float)w, 30.f);
glUniform2f(glGetUniformLocation(program, "rect_off"), 0.f, 0.f);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
                        </code></pre>
                        <br>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-frame.gif">
                        <br> <br>

                        <p>
                            In a borderless window, there is no specified non-client area. So to allow the user to drag the window
                            only from a specific place, we'll use <code>vd_fw_set_ncrects</code>.
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
int draggable_rect[4] = {
    0,  // left
    0,  // top
    w,  // right
    30, // bottom
};
vd_fw_set_ncrects(draggable_rect, 0, 0);
                        </code></pre>
                        <br>

                        <p>
                            Et voila!
                        </p>
                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-drag-frame.gif">
                        <br> <br>

                        <p>
                            Now you may, ask: <b>Why does the rectangle not move above the border when the mouse hovers it?</b>
                            <br> <br>

                            Well, by default, this library does not send mouse events in the non-excluded drag area. This is done
                            to prevent unwanted mouse movements inside an application's draggable area. To receive all non-client area events call:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
vd_fw_set_receive_ncmouse(1);
                        </code></pre>

                        <p>
                            After you've initialized the library.
                        </p>

                        <p>
                            Now, for the 2 last parameters to <code>vd_fw_set_ncrects</code>:
                            <ul>
                                <li>count: Number of excluded rects</li>
                                <li>rects: Pointer to array of <code>count</code> rects</li>
                            </ul>

                            These allow you to set areas inside the drag area, that are not draggable.
                        </p>

                        <p>
                            Let's draw a red 'close' button in our title bar, and if the mouse is over it, darken it:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
float button_color[4] = {1.0f, 0.0f, 0.0f, 1.0f};
int mouse_inside_close_button =
    (mx > ((float)w - 30.f)) &&
    (my > (0.f) && my < (30.f));

if (mouse_inside_close_button) {
    button_color[0] = 0.7f;    
    button_color[1] = 0.0f;    
    button_color[2] = 0.0f;    
    button_color[3] = 1.0f;    
}

glUniform4f(glGetUniformLocation(program, "rect_color"), button_color[0],
                                                         button_color[1],
                                                         button_color[2],
                                                         button_color[3]);
glUniform2f(glGetUniformLocation(program, "rect_size"), 30.f, 30.f);
glUniform2f(glGetUniformLocation(program, "rect_off"), (float)w - 30.f, 0.f);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-button.gif">
                        <br> <br>

                        <p>
                            As you can see, we can still drag the window even if the mouse is on the button. <br>
                            <br>
                            To fix that, we have to update our call to <code>vd_fw_set_ncrects</code>:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
int draggable_rect[4] = {
    0,  // left
    0,  // top
    w,  // right
    30, // bottom
};

int exclude_rects[1][4] = {
    {
        w - 30, // left
        0,      // top
        w,      // right
        30,     // bottom
    }
};
vd_fw_set_ncrects(draggable_rect, 1, exclude_rects);
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-button-no-drag.gif">
                        <br> <br>

                        <p>
                            The code is straightforward; we exclude the exact position of our red button.
                        </p>

                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-rendering-3d">
                        <h4>Render 3D</h4>
                        <p>
                            Let's render some 3D geometry.
                            For this, we'll need separate shaders; if you're following the tutorial in order, here they are:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
#define VERTEX_SOURCE3D \
"#version 330 core                                        \n" \
"layout (location = 0) in vec3 aPos;                      \n" \
"layout (location = 1) in vec2 aTexCoord;                 \n" \
"                                                         \n" \
"out vec2 TexCoord;                                       \n" \
"                                                         \n" \
"uniform mat4 projection;                                 \n" \
"uniform mat4 view;                                       \n" \
"                                                         \n" \
"void main()                                              \n" \
"{                                                        \n" \
"    gl_Position = projection * view * vec4(aPos, 1.0f);  \n" \
"    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);     \n" \
"}                                                        \n" \

#define FRAGMENT_SOURCE3D \
"#version 330 core                                        \n" \
"out vec4 FragColor;                                      \n" \
"                                                         \n" \
"in vec2 TexCoord;                                        \n" \
"                                                         \n" \
"uniform sampler2D texture1;                              \n" \
"                                                         \n" \
"void main()                                              \n" \
"{                                                        \n" \
"    FragColor = texture(texture1, TexCoord);             \n" \
"}                                                        \n" \
                        </code></pre>
                        <br>

                        <p>
                            We'll also create a 3d cube, and a checkerboard texture:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
float vertices3d[] = {
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
};

unsigned int VBO3D, VAO3D;
glGenVertexArrays(1, &VAO3D);
glGenBuffers(1, &VBO3D);
glBindVertexArray(VAO3D);
glBindBuffer(GL_ARRAY_BUFFER, VBO3D);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices3d), vertices3d, GL_STATIC_DRAW);
// position attribute
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// texture coord attribute
glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);

unsigned int checkerboard[] = {
    0xFFFFFFFF, 0xFF000000,
    0xFF000000, 0xFFFFFFFF
};

GLuint texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 2, 2, 0, GL_RGBA, GL_UNSIGNED_BYTE, checkerboard);
glGenerateMipmap(GL_TEXTURE_2D);
                        </code></pre>
                        <br>

                        <p>
                            Since we'll be rendering both 3D and 2D, we'll need to make sure GL_DEPTH_TEST is only
                            enabled for the 3D part of our rendering;
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
glDisable(GL_DEPTH_TEST);
glUseProgram(program);
glBindVertexArray(VAO);

float projection[16];
vd_fw_u_ortho(0.f, (float)w, (float)h, 0.f, -1.f, 1.f, projection);
glUniformMatrix4fv(glGetUniformLocation(program, "projection"), 1, GL_FALSE, projection);
// ... Rest of 2D rendering code

glEnable(GL_DEPTH_TEST);
// 3D rendering code
                        </code></pre>

                        <p>
                            Before our main loop, we're also going to add some variables for the camera:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
float camera_position[3] = {0.f, 0.f, -2.f};
float camera_yaw   = 0.f;
float camera_pitch = 30.f;
float deg2rad = 3.14159265359f / 180.f;
float camera_speed = 2.f;
                        </code></pre>

                        <p>
                            Now for rendering the cube depending on camera position:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
glEnable(GL_DEPTH_TEST);
float fw = (float)w;
float fh = (float)h;

// Compute forward vector
float camera_forward[3] = {
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_SIN(deg2rad * camera_yaw),
    VD_FW_SIN(deg2rad * camera_pitch),
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_COS(deg2rad * camera_yaw)
};

// Normalize forward vector
float camera_forward_len = VD_FW_SQRT(
    camera_forward[0] * camera_forward[0] +
    camera_forward[1] * camera_forward[1] +
    camera_forward[2] * camera_forward[2]);

camera_forward[0] = camera_forward[0] / camera_forward_len;
camera_forward[1] = camera_forward[1] / camera_forward_len;
camera_forward[2] = camera_forward[2] / camera_forward_len;

float camera_ref_up[3] = {0.f, 1.f, 0.f};

// Compute right vector by taking the cross product of foward x up
float camera_right[3] = {
    camera_forward[1] * camera_ref_up[2] - camera_forward[2] * camera_ref_up[1],
    camera_forward[2] * camera_ref_up[0] - camera_forward[0] * camera_ref_up[2],
    camera_forward[0] * camera_ref_up[1] - camera_forward[1] * camera_ref_up[0],
};

// Normalize right vector
float camera_right_len = VD_FW_SQRT(
    camera_right[0] * camera_right[0] +
    camera_right[1] * camera_right[1] +
    camera_right[2] * camera_right[2]);

camera_right[0] = camera_right[0] / camera_right_len;
camera_right[1] = camera_right[1] / camera_right_len;
camera_right[2] = camera_right[2] / camera_right_len;

glViewport(0, 0, w, h - 30);
glUseProgram(program3d);
glBindVertexArray(VAO3D);

float projection[16] = {0.f};
vd_fw_u_perspective(60.f, fw / fh, 0.1f, 100.0f, projection);

float view[16] = {0.f};
float ctar[3] = {
    camera_position[0] + camera_forward[0],
    camera_position[1] + camera_forward[1],
    camera_position[2] + camera_forward[2]};
float cup[3]  = {0.f, 1.f, 0.f};
vd_fw_u_lookat(camera_position, ctar, cup, view);

glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture);

glUseProgram(program3d);
glUniformMatrix4fv(glGetUniformLocation(program3d, "projection"), 1, GL_FALSE, projection);
glUniformMatrix4fv(glGetUniformLocation(program3d, "view"), 1, GL_FALSE, view);
glUniform1i(glGetUniformLocation(program3d, "texture1"), 0);

glBindVertexArray(VAO3D);

glDrawArrays(GL_TRIANGLES, 0, 36);
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-rendering-cube.gif">
                        <br> <br>

                        <p>
                            And here we have a 3d cube! As you can see, I've already added the movement of the camera
                            for demonstration purposes, but we'll have a look at input in the next section.
                        </p>

                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-input">
                        <h4>Input</h4> 

                        <p>
                            We've already seen some mouse state handling, but let's look at the main functions used for
                            input:
                            <ul>
                                <li><code>vd_fw_delta_s</code>, to get delta time since last frame</li>
                                <li><code>vd_fw_get_mouse_state</code>, to read the mouse state</li>
                                <li><code>vd_fw_get_mouse_delta</code>, to read how much the mouse moved since last frame</li>
                                <li><code>vd_fw_get_key_down</code>, to check if a key is currently down</li>
                                <li><code>vd_fw_get_key_pressed</code>, to check if a key was just pressed</li>
                                <li><code>vd_fw_set_mouse_locked</code>, to hide and confine the mouse to the window</li>
                            </ul>
                        </p>

                        <p>
                            So let's add some camera manipulation, we'll start by getting the delta time in seconds:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
float ds = vd_fw_delta_s();
                        </code></pre>

                        <p>
                            It's also common to lock the mouse and hide it, so let's do that as well at the start of the
                            application:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
vd_fw_set_mouse_locked(1);
                        </code></pre>

                        <p>
                            Here's also the snippet moving the camera:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
// Get key states
float fwdir = (float)(vd_fw_get_key_down('W') - vd_fw_get_key_down('S'));
float rgdir = (float)(vd_fw_get_key_down('A') - vd_fw_get_key_down('D'));
float updir = (float)(vd_fw_get_key_down('Q') - vd_fw_get_key_down('E'));

// Compute overall move direction
float camera_move_dir[3] = {
    fwdir * camera_forward[0] + rgdir * camera_right[0] + updir * camera_ref_up[0],
    fwdir * camera_forward[1] + rgdir * camera_right[1] + updir * camera_ref_up[1],
    fwdir * camera_forward[2] + rgdir * camera_right[2] + updir * camera_ref_up[2],
};

// Normalize move direction, if it's length is not too small (i.e. we're not pressing any keys)
float camera_dir_lensq = 
    camera_move_dir[0] * camera_move_dir[0] +
    camera_move_dir[1] * camera_move_dir[1] +
    camera_move_dir[2] * camera_move_dir[2];

if (camera_dir_lensq > 0.0001f) {
    // Normalize move direction and apply it to the camera's position
    float camera_move_dir_len = VD_FW_SQRT(camera_dir_lensq);

    camera_move_dir[0] = camera_move_dir[0] / camera_move_dir_len;
    camera_move_dir[1] = camera_move_dir[1] / camera_move_dir_len;
    camera_move_dir[2] = camera_move_dir[2] / camera_move_dir_len;

    camera_position[0] += camera_move_dir[0] * camera_speed * ds;
    camera_position[1] += camera_move_dir[1] * camera_speed * ds;
    camera_position[2] += camera_move_dir[2] * camera_speed * ds;
}
                        </code></pre>

                        <p>
                            Finally, inside of our rendering loop, we compute the camera's pitch and yaw based on the mouse:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
if (vd_fw_get_mouse_locked()) {
    float mouse_delta_x, mouse_delta_y;
    vd_fw_get_mouse_delta(&mouse_delta_x, &mouse_delta_y);

    camera_yaw   += mouse_delta_x;
    camera_pitch -= mouse_delta_y;
};

if (camera_pitch < -89.9f) camera_pitch = -89.9f;
if (camera_pitch > +89.9f) camera_pitch = +89.9f;

if (camera_yaw > +360.f) camera_yaw -= 360.f;
if (camera_yaw < -360.f) camera_yaw += 360.f;

float camera_forward[3] = {
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_SIN(deg2rad * camera_yaw),
    // ..
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-rendering-camera.gif">
                        <br> <br>

                        <p>
                            Okay, we can move the cube, but we can't really exit the application easily, since the mouse
                            is confined. Let's make 'Shift + F1' unlock the mouse:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
if (vd_fw_get_key_pressed(VD_FW_KEY_F1) && vd_fw_get_key_down(VD_FW_KEY_LSHIFT)) {
    vd_fw_set_mouse_locked(!vd_fw_get_mouse_locked());
}
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-rendering-cubeapp.gif">
                        <br> <br>

                        <p>
                            And we finally have a resizable, draggable window with our own custom button and cube.
                        </p>

                    </section>

                    <!-- Begin API -->
                    <section class="L1 section" id="api-ref">
                        <h4>Reference</h4>
                        <hr>
                        <!-- VD_FW_API int                vd_fw_init(VdFwInitInfo *info); -->
                        <div id="vd_fw_init" class="L2 apiitem function">
                            <span class="item-decl">int vd_fw_init(VdFwInitInfo *info)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Initializes the library. Any call before this is invalid.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>info</td>
                                        <td>Options for the window and OpenGL context. Leave null for default.</td>
                                    </tr>
                                </tbody>
                                </table>

                                <h6>Remarks</h6>
                                <p>
                                    - Why not use a parameter list?<br>
                                    It's easier update the function's signature, and much easier for the user to just 
                                    copy and paste a struct, and modify its values.
                                </p>

                                <p>
                                    In C99, you can also do this:
                        <pre class="rounded copy"><code class="language-cpp">
vd_fw_init(& (VdFwInitInfo) {
    .gl = {
        .version = VD_FW_GL_VERSION_3_3,
    },
});
                        </code></pre>

                                </p>
                            </div>
                        </div>

                        <!--                                                 VdFwInitInfo -->
                        <div id="VdFwInitInfo" class="L2 apiitem function">
                            <span class="item-decl">VdFwInitInfo</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Info struct passed to <code>vd_fw_init</code>.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>VdFwInitInfo::gl::version</td>
                                        <td>Version of OpenGL to load.</td>
                                    </tr>
                                    <tr><td>VdFwInitInfo::gl::debug_on</td>
                                        <td>Enable <a href="https://www.khronos.org/opengl/wiki/Debugging_Tools#Debug_Output">debugging for OpenGL</a>.</td>
                                    </tr>
                                    <tr><td>VdFwInitInfo::window_options::borderless</td>
                                        <td>Set to 1 to disable window decorations.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <div id="VdFwGlVersion" class="L2 apiitem function">
                            <span class="item-decl">VdFwGlVersion</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    OpenGL version to use, passed in <code>VdFwInitInfo</code>.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>VD_FW_GL_VERSION_BASIC</td>
                                        <td>Defaults to a known good version of OpenGL (3.3).</td> 
                                    <tr><td>VD_FW_GL_VERSION_1_0</td>
                                        <td>OpenGL Version 1.0</td> 
                                    <tr><td>VD_FW_GL_VERSION_1_2</td>
                                        <td>OpenGL Version 1.2</td> 
                                    <tr><td>VD_FW_GL_VERSION_1_3</td>
                                        <td>OpenGL Version 1.3</td> 
                                    <tr><td>VD_FW_GL_VERSION_1_4</td>
                                        <td>OpenGL Version 1.4</td> 
                                    <tr><td>VD_FW_GL_VERSION_1_5</td>
                                        <td>OpenGL Version 1.5</td> 
                                    <tr><td>VD_FW_GL_VERSION_2_0</td>
                                        <td>OpenGL Version 2.0</td> 
                                    <tr><td>VD_FW_GL_VERSION_2_1</td>
                                        <td>OpenGL Version 2.1</td> 
                                    <tr><td>VD_FW_GL_VERSION_3_0</td>
                                        <td>OpenGL Version 3.0</td> 
                                    <tr><td>VD_FW_GL_VERSION_3_1</td>
                                        <td>OpenGL Version 3.1</td> 
                                    <tr><td>VD_FW_GL_VERSION_3_2</td>
                                        <td>OpenGL Version 3.2</td> 
                                    <tr><td>VD_FW_GL_VERSION_3_3</td>
                                        <td>OpenGL Version 3.3</td> 
                                    <tr><td>VD_FW_GL_VERSION_4_0</td>
                                        <td>OpenGL Version 4.0</td> 
                                    <tr><td>VD_FW_GL_VERSION_4_1</td>
                                        <td>OpenGL Version 4.1</td> 
                                    <tr><td>VD_FW_GL_VERSION_4_2</td>
                                        <td>OpenGL Version 4.2</td> 
                                    <tr><td>VD_FW_GL_VERSION_4_3</td>
                                        <td>OpenGL Version 4.3</td> 
                                    <tr><td>VD_FW_GL_VERSION_4_4</td>
                                        <td>OpenGL Version 4.4</td> 
                                    <tr><td>VD_FW_GL_VERSION_4_5</td>
                                        <td>OpenGL Version 4.5</td> 
                                    <tr><td>VD_FW_GL_VERSION_4_6</td>
                                        <td>OpenGL Version 4.6</td> 
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <div id="vd_fw_running" class="L2 apiitem function">
                            <span class="item-decl">int vd_fw_running(void)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Check if the application is running. Call this every frame.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>Return Value</td>
                                        <td>1 if running, 0 otherwise.</td>
                                    </tr>
                                </tbody>
                                </table>

                                <h6>Remarks</h6>
                                <p>
                                    Some details about the internals of this function:<br>
                                    <br>
                                    Typically, most graphics applications use only one thread, the main thread.
                                    This covers most of the use cases, but many windowing APIs (at least for the big
                                    threes: Windows, MacOS and Linux) block or enter some kind of internal loop when
                                    the window is moved or resized.
                                    <br><br>
                                    This results in the application freezing once these events happen. Most solutions
                                    to this are implemented by creating a separate thread to which rendering is
                                    delegated to, and updating a condition variable or some other synchronization
                                    construct to signal to the render thread that it should render, or wait for the
                                    appropriate time to render. 
                                    <br><br>
                                    Here, we do kind of the reverse: We spawn a separate thread for the windowing and
                                    input, and do the rendering on the main thread.
                                    <br><br>
                                    For input, most of the input events are cached or swallowed into sinks to make the
                                    interface of the library immediate-mode and easy to use. For the most part
                                    the windowing thread sleeps on messages.
                                    <br><br>
                                    This function, as well as <a href="#vd_fw_swap_buffers">vd_fw_swap_buffers</a> do
                                    a bit more than just checking if the window is running and swapping buffers. This
                                    function for example:
                                    <ul>
                                        <li>Checks a semaphore to see if the window was closed.</li>
                                        <li>Zeroes/Updates cached key/mouse states.</li>
                                        <li>Checks messages on a small interlocked circular queue.</li>
                                        <li>Enters Mutex/Critical Section and gets frame info (width, height)</li>
                                        <li>Handles mouse locking behavior.</li>
                                    </ul>
                                </p>
                            </div>
                        </div>

                        <!-- VD_FW_API int                vd_fw_swap_buffers(void); -->
                        <div id="vd_fw_swap_buffers" class="L2 apiitem function">
                            <span class="item-decl">int vd_fw_swap_buffers(void)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    End rendering and swap buffers. Call this right at the end of your rendering code.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>Return Value</td>
                                        <td>(Reserved for future use)</td>
                                    </tr>
                                </tbody>
                                </table>
                                <h6>Remarks</h6>
                                <p>
                                    As mentioned in <a href="#vd_fw_running">vd_fw_running</a>, this function does a bit
                                    more than just swapping buffers:
                                    <ul>
                                        <li>It (of course) swaps the buffers.</li>
                                        <li>Performs glFenceSync/glClientWaitSync to better synchronize frame
                                            timing</li>
                                        <li>Wakes up window thread (if it needs to be woken up)</li>
                                    </ul>
                                </p>
                            </div>
                        </div>

                        <!-- VD_FW_API int                vd_fw_get_size(int *w, int *h); -->
                        <div id="vd_fw_get_size" class="L2 apiitem function">
                            <span class="item-decl">int vd_fw_get_size(int *w, int *h)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Get the window size, in pixels.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>w</td>
                                        <td>Pointer to int that will receive window width.</td>
                                    </tr>
                                    <tr><td>h</td>
                                        <td>Pointer to int that will receive window height.</td>
                                    </tr>
                                    <tr><td>Return Value</td>
                                        <td>1 if the window size changed since last frame.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- VD_FW_API int                vd_fw_get_focused(int *focused); -->
                        <div id="vd_fw_get_focused" class="L2 apiitem function">
                            <span class="item-decl">int vd_fw_get_focused(int *focused)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Get whether the window is focused.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>focused</td>
                                        <td>Pointer to int that will receive window focus state.</td>
                                    </tr>
                                    <tr><td>Return Value</td>
                                        <td>1 if the window focus changed since last frame.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- VD_FW_API unsigned long long vd_fw_delta_ns(void); -->
                        <div id="vd_fw_delta_ns" class="L2 apiitem function">
                            <span class="item-decl">unsigned long long vd_fw_delta_ns(void)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Get the delta time since last frame, in nanoseconds.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>Return Value</td>
                                        <td>The delta time, in nanoseconds.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- VD_FW_INL float              vd_fw_delta_s(void); -->
                        <div id="vd_fw_delta_s" class="L2 apiitem function">
                            <span class="item-decl">float vd_fw_delta_s(void)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Utility function. Get the delta time since last frame, in seconds.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>Return Value</td>
                                        <td>The delta time, in seconds.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- VD_FW_API int                vd_fw_set_vsync_on(int on); -->
                        <div id="vd_fw_set_vsync_on" class="L2 apiitem function">
                            <span class="item-decl">int vd_fw_set_vsync_on(int on)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Set the VSYNC count.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>on</td>
                                        <td>Whether vsync is on. Additionally, the number of frames to sync on.</td>
                                    </tr>
                                    <tr><td>Return Value</td>
                                        <td>Whether the requested vsync count was accepted.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- VD_FW_API int                vd_fw_get_mouse_state(int *x, int *y); -->
                        <div id="vd_fw_get_mouse_state" class="L2 apiitem function">
                            <span class="item-decl">int vd_fw_get_mouse_state(int *x, int *y);</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Get the current mouse state.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>x</td>
                                        <td>Pointer to int that will receive the mouse X coordinate relative to the window.</td>
                                    </tr>
                                    <tr><td>y</td>
                                        <td>Pointer to int that will receive the mouse Y coordinate relative to the window.</td>
                                    </tr>
                                    <tr><td>Return Value</td>
                                        <td>
                                            The mouse state flags:<br>
                                            <ul>
                                                <li><code>VD_FW_MOUSE_STATE_LEFT_BUTTON_DOWN</code>: Left mouse button</li>
                                                <li><code>VD_FW_MOUSE_STATE_RIGHT_BUTTON_DOWN</code>: Right mouse button</li>
                                                <li><code>VD_FW_MOUSE_STATE_MIDDLE_BUTTON_DOWN</code>: Middle mouse button</li>
                                            </ul>
                                        </td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- VD_FW_API void               vd_fw_set_ncrects(int caption[4], int count, int (*rects)[4]); -->
                        <div id="vd_fw_set_ncrects" class="L2 apiitem function">
                            <span class="item-decl">void vd_fw_set_ncrects(int caption[4], int count, int (*rects)[4])</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Set the non client rectangles where the window will be draggable, and also set the
                                    optionally the rectangles that will be excluded from the drag area.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>caption</td>
                                        <td>An all encompassing rectangle that determines the drag area.</td>
                                    </tr>
                                    <tr><td>count</td>
                                        <td>The number of excluded rectangles</td>
                                    </tr>
                                    <tr><td>rects</td>
                                        <td>An array of <code>count</code> rectangles (left, top, right, bottom), that will be excluded.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- VD_FW_API void               vd_fw_set_receive_ncmouse(int on); -->
                        <div id="vd_fw_set_receive_ncmouse" class="L2 apiitem function">
                            <span class="item-decl">void vd_fw_set_receive_ncmouse(int on)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Sets whether or not mouse events will be pushed if the mouse is inside the drag area<br>
                                    and not inside any of the excluded rectangles (if any).
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>on</td>
                                        <td>Whether to enable this functionality.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- VD_FW_API unsigned int       vd_fw_compile_shader(unsigned int type, const char *source); -->
                        <div id="vd_fw_compile_shader" class="L2 apiitem function">
                            <span class="item-decl">unsigned int vd_fw_compile_shader(unsigned int type, const char *source)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Compiles a shader from <code>source</code> with type <code>type</code>.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>type</td>
                                        <td>Shader type (as you would pass in <code>glCreateShader</code>).</td>
                                    </tr>
                                    <tr><td>source</td>
                                        <td>Null terminated string containing the source code.</td>
                                    </tr>
                                    <tr><td>Return Value</td>
                                        <td>The shader id.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                    </section>
                    <!--   End API -->

                    <div class="d-flex">
                        <span class="text-muted flex-grow-1 align-self-end">&copy; Michael Dodis, 2025-2026.</span>
                        <button type="button" class="btn ms-2 btn-outline-success" onclick="window.print();">PDF</button>
                        <a download type="button" class="btn ms-2 btn-outline-success" href="https://raw.githubusercontent.com/mdodis/vd-libs/main/vd_fw.h">Download</a>
                    </div>

                </div>

        <footer class="footer mt-auto py-3 bg-dark">
            <div class="container">
            </div>
        </footer>

            </div>
        </div>
        <!--   End Content -->

        <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"> -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
                integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI"
                crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
                integrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
                crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="/auto-toc.js"></script>
        <script src="/index.js"></script>
    </body>
</html>