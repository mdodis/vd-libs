<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
    <head>
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>VD Libs - vd_fw.h</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
        <link rel="stylesheet" href="/style.css">
    </head>
    <body data-bs-spy="scroll" data-bs-target="#toc" data-bs-offset="70" tabindex="0">
        <!-- Begin Navbar -->
        <nav id="mainnav" class="navbar sticky-top navbar-expand-md bg-body-tertiary">
            <div class="container-fluid">
                <a class="navbar-brand" href="/index.html">
                    <img    src="/assets/vd-logo-p@1x.png"
                         srcset="/assets/vd-logo-p@1x.png 1x, /assets/vd-logo-p@2x.png 2x"
                            alt="Brand"
                          width="64"
                         height="38.5">
                </a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" 
                        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav">
                        <li class="nav-item">
                            <a class="nav-link" aria-current="page" href="/index.html">Home</a>
                        </li>
                        <!-- Begin Files -->
                        <li class="nav-item dropdown">
                            <a class="nav-link active dropdown-toggle" href="#" id="documentationDropdown" role="button" 
                               data-bs-toggle="dropdown" aria-expanded="false">
                                Documentation
                            </a>
                            <ul class="dropdown-menu" aria-labelledby="documentationDropdown">
                                <li><a class="dropdown-item"        href="/vd/index.html"   >vd.h</a></li>
                                <li><a class="dropdown-item active" href="/vd_fw/index.html">vd_fw.h</a></li>
                            </ul>
                        </li>
                        <!--   End Files -->
                    </ul>

                </div>
            </div>
        </nav>
        <!--   End Navbar -->


        <!-- Begin Content -->
        <div class="container">
            <div class="row justify-content-center">
                <div id="main-content" class="col-12 col-sm-10 col-md-8 col-lg-8 text-start mx-auto" style="margin-top: 0px;">

                    <nav id="toc" data-toc class="toc-outline d-none d-lg-flex p-0 nav outline-section flex-column">
                        
                    </nav>

                    <!-- <nav id="toc" class="toc-outline d-none d-lg-flex p-0 nav outline-section flex-column">
                        <a class="nav-link" href="#brief">Brief</a>
                        <a class="nav-link" href="#linking">Linking & Dependencies</a>
                        <div class="nav outline-section flex-column ms-3">
                            <a class="nav-link" href="#linking-windows">Windows</a>
                            <a class="nav-link" href="#linking-macos">MacOS</a>
                        </div>
                        <a class="nav-link" href="#support">Support</a>
                        <div class="nav outline-section flex-column ms-3">
                            <a class="nav-link" href="#platforms">Platforms</a>
                            <a class="nav-link" href="#revisions">Revisions</a>
                        </div>
                        <a class="nav-link" href="#tutorials">Tutorials</a>
                        <div class="nav outline-section flex-column ms-3">
                            <a class="nav-link" href="#tutorials-main-loop">Main Loop</a>
                            <a class="nav-link" href="#tutorials-choose-version">Choose OpenGL Version</a>
                            <a class="nav-link" href="#tutorials-borderless-window">Create a Borderless Window</a>
                            <a class="nav-link" href="#tutorials-compiling-shaders">Create a Shader Program</a>
                            <a class="nav-link" href="#tutorials-creating-vertex-buffer">Draw a Rectangle</a>
                            <a class="nav-link" href="#tutorials-ncrects">Set the Drag Area</a>
                            <a class="nav-link" href="#tutorials-rendering-3d">Render 3D</a>
                            <a class="nav-link" href="#tutorials-input">Input</a>
                        </div>
                        <a class="nav-link" href="#api-ref">Reference</a>
                    </nav> -->

                    <section class="L1 section" id="brief">
                        <h4 id="brief">Brief</h4>
                        <hr>

                        <img    src="/assets/fw/vd-fw-logo@1x.png"
                             srcset="/assets/fw/vd-fw-logo@1x.png 1x, /assets/fw/vd-fw-logo@2x.png 2x"
                              width="128"
                             height="106.5"
                             class="span-image">
                        <p>
                            A library that gets you a semi-customizable window and an OpenGL context, minimizing 
                            dependencies and hiding the complexities of doing proper windowing on each platform.
                        </p>

                        <p>
                            It's written with performance in mind; though performance is not the main focus of it.
                            <b>Maintainability</b>, <b>support</b> for the defined feature set and <b>ease of use</b> are the primary
                            targets of this library.
                        </p>

                        <p>
                            <b>Why should you use this library over, GLFW, SDL, SFML, ...?</b>
                            <br>

                            Those libraries solve a <b>much more</b> general problem than the one most developers have:
                            <ul>
                                <li>Create one or more windows</li>
                                <li>Enable/disable window styling</li>
                                <li>Handle child/parent window relationships</li>
                                <li>Provide aliases for common usermode operations (show file dialog, message box)</li>
                                <li>Support many more platforms, even ones that don't include a windowing system.</li>
                                <li>Support multiple graphics APIs for initialization.</li>
                                <li>Provide a high level drawing interface.</li>
                                <li>Provide a high level sound interface.</li>
                                <li>Allow for entirely customized windows.</li>
                                <li>And much more...</li>
                            </ul>

                            But in their attempt to be "generic" and "robust", they fail to provide a good and simple interface
                            that covers 90% of the use cases, that is implemented in the best way possible for each platform
                        </p>

                        <p>
                            One common example is that every other popular windowing library on Windows does not allow the
                            developer to draw while resizing or moving the window.

                            This is an introcacy of the Win32 API (and actually the same is true for MacOS), and the recommended way
                            is not exactly obvious to a new developer, or one unfamiliar with the platform.
                            <br>
                        </p>

                        <p>
                            Another gripe I have with these libraries is that for OpenGL you are <b>required</b> to either bring
                            in your own loader, or use an off the shelf one, even though when someone is only starting to learn
                            graphics programming, they don't know the difference between "Core Profile", "Compatibility Profile",
                            or even what an extension is.
                        </p>

                        <div class="alert alert-primary d-flex align-items-center" role="alert">
                            <div>
                                Note that you don't need to use an OpenGL loader or include any OS specific OpenGL libraries.
                                <br>
                                The library does the loading for you.
                            </div>
                        </div>

                        <p>
                            Here is all you need (and should need) to create a simple window.
                            <br>
                            By default it creates an OpenGL 3.3 core profile context:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
#include "vd_fw.h"                                           // Include library
int main() {
    vd_fw_init(NULL);                                        // Initialize library
    while (vd_fw_running()) {                                // Check if the window is closed & gather events
        glClearColor(0.5f, 0.3f, 0.2f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        vd_fw_swap_buffers();                                // Swap buffers
    }
    return 0;
}

#define VD_FW_IMPL                                           // Include implementation code
#include "vd_fw.h"
                        </code></pre>

                        <div id="fw-window-simple" class="rounded carousel slide">
                            <div class="carousel-inner">
                               <div class="carousel-item active">
                                    <img class="img-fluid" src="/assets/fw/window-simple-win32.png">
                               </div> 
                               <div class="carousel-item">
                                    <img class="img-fluid" src="/assets/fw/window-simple-macos.png">
                               </div> 
                            </div>
                            <button class="carousel-control-prev" type="button" data-bs-target="#fw-window-simple" data-bs-slide="prev">
                                <span class="carousel-control-prev-icon" style="filter: invert(1) grayscale(100%) brightness(200%);" aria-hidden="true"></span>

                                <span class="visually-hidden">Previous</span>
                            </button>
                            <button class="carousel-control-next" type="button" data-bs-target="#fw-window-simple" data-bs-slide="next">
                                <span class="carousel-control-next-icon" style="filter: invert(1) grayscale(100%) brightness(200%);" aria-hidden="true"></span>
                                <span class="visually-hidden">Next</span>
                            </button>
                        </div>
                    </section>
                    <br>

                    <section class="L1 section" id="linking">
                        <h4>Linking & Dependencies</h4>
                        <hr>


                        The library is distributed as a single, header-only file, thus the following instructions are meant to
                        be considered for your final application/dynamic library.
                    </section>
                    <br>


                    <section class="L2 section" id="linking-windows">
                        <h4>Windows</h4>
                        <p>
                            With MSVC you don't really need to link anything, since linker directives in the
                            translation unit that includes vd_fw.h are defined, so that the appropriate libraries
                            and subsystem are used. But for reference, here they are:
                        </p>
                        <ol class="list-group">
                            <li class="list-group-item">User32</li>
                            <li class="list-group-item">OpenGL32</li>
                            <li class="list-group-item">Dwmapi</li>
                            <li class="list-group-item">Shcore</li>
                            <li class="list-group-item">Gdi32</li>
                            <li class="list-group-item">uxtheme</li>
                            <li class="list-group-item">shell32</li>
                            <li class="list-group-item">kernel32</li>
                            <li class="list-group-item">winmm</li>
                        </ol>
                        <br>
                        <p>
                            To set the subsystem of the application: 
                            <ul>
                                <li> Windows: <code>#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_WINDOWS</code> </li>
                                <li> Console: <code>#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_CONSOLE</code> </li>
                            </ul>
                        </p>

                        <p>
                            If you're on the Windows subsystem, but would still like a console for debugging purposes, this
                            can be done by setting <code>VdFwInitInfo::gl_options::debug_on = 1</code> when calling
                            <code>vd_fw_init</code>.

                            <br>
                            This will allocate a console and set-up the relevant gl debug callback for you.
                        </p>

                        <p>
                            It's highly recommended to <code>#define VD_FW_NO_CRT 1</code> so that the CRT is removed
                            when linking. This can reduce the final executable size by a factor of 10 (for small applications).
                        </p>
                    </section>

                    <section class="L2 section" id="linking-macos">
                        <h4>MacOS</h4>
                        <p>
                            For MacOS, it's a bit different. with clang, you must link several frameworks (via <code>-framework framework_name</code>).
                            Additionally, <code>-x objective-c</code> must be used since the Mac APIs use Objective-C.
                        </p>
                        <ol class="list-group">
                            <li class="list-group-item">pthread (compiler flag)</li>
                            <li class="list-group-item">Cocoa</li>
                            <li class="list-group-item">Metal</li>
                            <li class="list-group-item">QuartzCore</li>
                            <li class="list-group-item">CoreGraphics</li>
                            <li class="list-group-item">IOSurface</li>
                            <li class="list-group-item">IOKit</li>
                            <li class="list-group-item">Foundation</li>
                            <li class="list-group-item">OpenGL</li>
                        </ol>
                        <br>
                    </section>
                    <br>

                    <section class="L1 section" id="support">
                        <h4>Support</h4>
                        <hr>

                        <pre class="rounded copy"><code class="language-txt">
zlib License

(C) Copyright 2025-2026 Michael Dodis (michaeldodisgr@gmail.com)
 This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
                        </code></pre>

                        <p>
                            As stated in the license, no warranty or guarantee is provided by the use of this software library.    
                        </p>

                        <p>
                            That being said, I will look at issues when I have the time, and/or if they are important to the core
                            principles of this library.
                        </p>

                        <p><a class="link-opacity-100" href="https://github.com/mdodis/vd-libs/issues/new">Submit issues here</a></p>
                    </section>

                    <section class="L2 section" id="platforms">
                        <h4>Platforms</h4>
                        <p>
                            Due to platform limitations, platform-specific APIs and frameworks, vd_fw.h will
                            never have support for some platforms. One example is Android, where Java is required.
                        </p>
                        <p>
                            Though, I'm still thinking about how this can be done easily, so I will leave the possibility
                            open.
                        </p>
                        <table class="table">
                            <tr>
                                <th scope="col">Platform</th>
                                <th scope="col">Supported</th>
                            </tr>
                            <tbody>
                                <tr>
                                    <td>Windows</td>
                                    <td class="table-success">Yes</td>
                                </tr>
                                <tr>
                                    <td>MacOS</td>
                                    <td class="table-warning">In Progress</td>
                                </tr>
                                <tr>
                                    <td>Linux (X11)</td>
                                    <td>Coming soon...</td>
                                </tr>
                                <tr>
                                    <td>Linux (Wayland)</td>
                                    <td>Not Planned</td>
                                </tr>
                                <tr>
                                    <td>iOS</td>
                                    <td>Not Planned</td>
                                </tr>
                                <tr>
                                    <td>Android</td>
                                    <td>Not Planned</td>
                                </tr>
                                <tr>
                                    <td>Web</td>
                                    <td>Not Planned</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>

                    <section class="L2 section" id="revisions">
                        <h4>Revisions</h4> 
                        <div class="list-group">
                            <a class="list-group-item">
                                <div class="d-flex w-100 justify-content-between">
                                    <h5 class="mb-1">1.0.0</h5>
                                    <small class="text-body-secondary">xx/xx/xxxx</small>
                                </div>
                                <p class="mb-1">
                                    Initial Release:
                                    <ul>
                                        <li>Full Win32 support</li>
                                        <li>Partial MacOS support</li>
                                    </ul>
                                </p>
                            </a>
                        </div>

                    </section>
                    <br>

                    <section class="L1 section" id="tutorials">
                        <h4>Tutorials</h4>
                        <hr>
                        <p>
                            A collection of tutorials for how to use the library.
                        </p>

                        <p>
                            These do not show proper code, nor do they show correct OpenGL API usage, but they show various
                            features of vd_fw.h
                        </p>

                        <p>
                            We will start by creating a simple window, and continue with:
                            <ul>
                                <li>Making it borderless</li>
                                <li>Drawing a rectangle, and last</li>
                                <li>Setting the drag area</li>
                            </ul>

                            You can safely read each tutorial on its own, or in order. It will guide you through
                            almost all of the parts of the API
                        </p>

                        <p>
                            Additionally, several samples are available <a href="https://github.com/mdodis/vd-libs/tree/main/samples">here</a>,
                            which map to several parts of the tutorial.
                        </p>

                        <p>
                            This tutorial is written in C, but you can safely use C++ with it
                        </p>
                    </section>
                    <br>


                    <section class="L2 section" id="tutorials-main-loop">
                        <h4>Main Loop</h4>
                        <p>
                            Let's look at the main loop.
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
#define VD_FW_NO_CRT 0                                       // Disable CRT, this is highly recommended,
                                                             // if you know what you're doing.
#define VD_FW_WIN32_SUBSYSTEM VD_FW_WIN32_SUBSYSTEM_WINDOWS  // Disable console (Windows)
#include "vd_fw.h"

int main(int argc, char const *argv[])
{
    vd_fw_init(NULL);                                        // Initialize library
    vd_fw_set_vsync_on(1);                                   // Enable VSYNC

    while (vd_fw_running()) {                                // Check if user closed the window

        int w, h;
        vd_fw_get_size(&w, &h);                              // Get window size, in pixels.

        glViewport(0, 0, w, h);                              // Setup viewport
        glClearColor(0.5f, 0.3f, 0.2f, 1.0f);                // Select clear color
        glClear(GL_COLOR_BUFFER_BIT);                        // Clear

        vd_fw_swap_buffers();                                // Swap buffers
    }

    return 0;
}

#define VD_FW_IMPL                                           // Include implementation
#include "vd_fw.h"
                        </code></pre>
                        <br>

                        <p>
                            This will create a window, that can be moved and resized.
                        </p>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-main-loop.gif">
                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-choose-version">
                        <h4>Choose OpenGL Version</h4>
                        <p>
                            To specify the OpenGL version, create a <code>VdFwInitInfo</code> struct, populate the
                            <code>VdFwInitInfo::gl::version</code> member, and pass it to <code>vd_fw_init</code>.
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
VdFwInitInfo init_info = {};
init_info.gl.version = VD_FW_GL_VERSION_4_5; // Set OpenGL Version
vd_fw_init(&init_info);
                        </code></pre>

                        <p>
                            For reference, here's all of the possible versions:
                        </p>

                        <pre class="rounded"><code class="language-cpp">
typedef enum {
    VD_FW_GL_VERSION_BASIC = 0,
    VD_FW_GL_VERSION_1_0   = 1,
    VD_FW_GL_VERSION_1_2   = 12,
    VD_FW_GL_VERSION_1_3   = 13,
    VD_FW_GL_VERSION_1_4   = 14,
    VD_FW_GL_VERSION_1_5   = 15,
    VD_FW_GL_VERSION_2_0   = 20,
    VD_FW_GL_VERSION_2_1   = 21,
    VD_FW_GL_VERSION_3_0   = 30,
    VD_FW_GL_VERSION_3_1   = 31,
    VD_FW_GL_VERSION_3_2   = 32,
    VD_FW_GL_VERSION_3_3   = 33,
    VD_FW_GL_VERSION_4_0   = 40,
    VD_FW_GL_VERSION_4_1   = 41,
    VD_FW_GL_VERSION_4_2   = 42,
    VD_FW_GL_VERSION_4_3   = 43,
    VD_FW_GL_VERSION_4_4   = 44,
    VD_FW_GL_VERSION_4_5   = 45,
    VD_FW_GL_VERSION_4_6   = 46,
} VdFwGlVersion;
                        </code></pre>

                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-borderless-window">
                        <h4>Create a Borderless Window</h4>
                        <p>
                            To create a borderless window, create a <code>VdFwInitInfo</code> struct, set
                            <code>VdFwInitInfo::window_options::borderless</code> to 1, and pass it to <code>vd_fw_init</code>.
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
VdFwInitInfo init_info = {};
init_info.window_options.borderless = 1;
vd_fw_init(&init_info);
                        </code></pre>
                        <br>

                        <p>
                            This will create a borderless window, that can be moved (by dragging any part of the window), and resized.
                        </p>
                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-borderless.gif">
                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-compiling-shaders">
                        <h4>Create a Shader Program</h4>
                        <p>
                            Let's create a simple 2D rectangle application.
                            <br>

                            We'll create some in-source shaders, and compile them, as we would in any OpenGL application.
                            If you'd like to follow along, here are the shaders we'll be using:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
#define VERTEX_SOURCE \
"#version 330 core                                                                                                 \n" \
"layout (location = 0) in vec2 aPos;                                                                               \n" \
"                                                                                                                  \n" \
"uniform vec2 rect_off;                                                                                            \n" \
"uniform vec2 rect_size;                                                                                           \n" \
"uniform mat4 projection;                                                                                          \n" \
"                                                                                                                  \n" \
"                                                                                                                  \n" \
"void main()                                                                                                       \n" \
"{                                                                                                                 \n" \
"    gl_Position = projection * vec4(aPos * rect_size + rect_off, 0.0, 1.0f);                                      \n" \
"}                                                                                                                 \n" \

#define FRAGMENT_SOURCE \
"#version 330 core                                                                                                 \n" \
"out vec4 FragColor;                                                                                               \n" \
"                                                                                                                  \n" \
"uniform vec4 rect_color;                                                                                          \n" \
"                                                                                                                  \n" \
"void main()                                                                                                       \n" \
"{                                                                                                                 \n" \
"    FragColor = rect_color;                                                                                       \n" \
"}                                                                                                                 \n" \
                        </code></pre>
                        <br>

                        <p>
                            And the typical OpenGL shader compilation code:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
const char *vertex_shader_source = VERTEX_SOURCE;
const char *fragment_shader_source = FRAGMENT_SOURCE;

// Compile shaders
GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vertex_shader, 1, &vertex_shader_source, 0);
glCompileShader(vertex_shader);

GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragment_shader, 1, &fragment_shader_source, 0);
glCompileShader(fragment_shader);

GLuint program = glCreateProgram();
glAttachShader(program, vertex_shader);
glAttachShader(program, fragment_shader);
glLinkProgram(program);
                        </code></pre>

                        <p>
                            In most tutorials, you'll be prompted to do error checking by doing <code>glGetShaderiv</code>,
                            then <code>glGetShaderInfoLog</code> and printing it out...
                            <br>

                            This library provides a convenience function (and more) to do that, and will also log the errors:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
GLuint vertex_shader   = vd_fw_compile_shader(GL_VERTEX_SHADER,   VERTEX_SOURCE);
GLuint fragment_shader = vd_fw_compile_shader(GL_FRAGMENT_SHADER, FRAGMENT_SOURCE);
                        </code></pre>

                        <p>
                            For error logging, make sure to set <code>VdFwInitInfo::gl::debug_on</code> to 1 when initializing the library.
                            Here's the <code>vd_fw_init</code> call we'll be using for the rest of these tutorials:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
vd_fw_init(& (VdFwInitInfo) {
    .gl = {
        .version = VD_FW_GL_VERSION_3_3,
        .debug_on = 1,
    },
    .window_options = {
        .borderless = 1,
    }
});
                        </code></pre>

                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-creating-vertex-buffer">
                        <h4>Draw a Rectangle</h4>
                        <p>
                            Continuing from the previous section, we create a vertex buffer for a 2d rectangle:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
float rect_vertices[] = {
     0.0f,  0.0f,
    +1.0f,  0.0f,
     0.0f, +1.0f,
    +1.0f, +1.0f
};

unsigned int VBO, VAO;
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);
glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(rect_vertices), rect_vertices, GL_STATIC_DRAW);
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
                        </code></pre>
                        <br>

                        <p>
                            And now for drawing a rectangle.
                            <br>

                            We'll use orthographic projection. vd_fw.h provides a simple utility function to compute it:
                            <code>vd_fw_u_ortho</code>
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
glUseProgram(program);
glBindVertexArray(VAO);

{
    float projection[16];
    vd_fw_u_ortho(0.f, (float)w, (float)h, 0.f, -1.f, 1.f, projection);
    glUniformMatrix4fv(glGetUniformLocation(program, "projection"), 1, GL_FALSE, projection);
}
                        </code></pre>
                        <br>

                        <p>
                            To test that the coordinate transformation is working, we'll map the top left of the rectangle
                            to the mouse. To get the mouse position & buttons, use <code>vd_fw_get_mouse_state</code> or <code>vd_fw_get_mouse_statef</code>:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
float mx, my;
vd_fw_get_mouse_statef(&mx, &my);

glUniform4f(glGetUniformLocation(program, "rect_color"), 1.f, 0.f, 0.f, 1.f);
glUniform2f(glGetUniformLocation(program, "rect_size"), 40.f, 40.f);
glUniform2f(glGetUniformLocation(program, "rect_off"), mx, my);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

glUseProgram(0);
glBindVertexArray(0);
                        </code></pre>
                        <br>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-drawing-a-rectangle.gif">

                    </section> 
                    <br>


                    <section class="L2 section" id="tutorials-ncrects">
                        <h4>Set the Drag Area</h4>
                        <p>
                            Let's draw a simple window frame using our rectangle "renderer":
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
glUniform4f(glGetUniformLocation(program, "rect_color"), 0.2f, 0.2f, 0.2f, 1.f);
glUniform2f(glGetUniformLocation(program, "rect_size"), (float)w, 30.f);
glUniform2f(glGetUniformLocation(program, "rect_off"), 0.f, 0.f);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
                        </code></pre>
                        <br>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-frame.gif">
                        <br> <br>

                        <p>
                            In a borderless window, there is no specified non-client area. So to allow the user to drag the window
                            only from a specific place, we'll use <code>vd_fw_set_ncrects</code>.
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
int draggable_rect[4] = {
    0,  // left
    0,  // top
    w,  // right
    30, // bottom
};
vd_fw_set_ncrects(draggable_rect, 0, 0);
                        </code></pre>
                        <br>

                        <p>
                            Et voila!
                        </p>
                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-drag-frame.gif">
                        <br> <br>

                        <p>
                            Now you may, ask: <b>Why does the rectangle not move above the border when the mouse hovers it?</b>
                            <br> <br>

                            Well, by default, this library does not send mouse events in the non-excluded drag area. This is done
                            to prevent unwanted mouse movements inside an application's draggable area. To receive all non-client area events call:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
vd_fw_set_receive_ncmouse(1);
                        </code></pre>

                        <p>
                            After you've initialized the library.
                        </p>

                        <p>
                            Now, for the 2 last parameters to <code>vd_fw_set_ncrects</code>:<br>
                            <ul>
                                <li>count: Number of excluded rects</li>
                                <li>rects: Pointer to array of <code>count</code> rects</li>
                            </ul>

                            These allow you to set areas inside the drag area, that are not draggable.
                        </p>

                        <p>
                            Let's draw a red 'close' button in our title bar, and if the mouse is over it, darken it:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
float button_color[4] = {1.0f, 0.0f, 0.0f, 1.0f};
int mouse_inside_close_button =
    (mx > ((float)w - 30.f)) &&
    (my > (0.f) && my < (30.f));

if (mouse_inside_close_button) {
    button_color[0] = 0.7f;    
    button_color[1] = 0.0f;    
    button_color[2] = 0.0f;    
    button_color[3] = 1.0f;    
}

glUniform4f(glGetUniformLocation(program, "rect_color"), button_color[0],
                                                         button_color[1],
                                                         button_color[2],
                                                         button_color[3]);
glUniform2f(glGetUniformLocation(program, "rect_size"), 30.f, 30.f);
glUniform2f(glGetUniformLocation(program, "rect_off"), (float)w - 30.f, 0.f);
glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-button.gif">
                        <br> <br>

                        <p>
                            As you can see, we can still drag the window even if the mouse is on the button. <br>
                            <br>
                            To fix that, we have to update our call to <code>vd_fw_set_ncrects</code>:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
int draggable_rect[4] = {
    0,  // left
    0,  // top
    w,  // right
    30, // bottom
};

int exclude_rects[1][4] = {
    {
        w - 30, // left
        0,      // top
        w,      // right
        30,     // bottom
    }
};
vd_fw_set_ncrects(draggable_rect, 1, exclude_rects);
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-ncrects-button-no-drag.gif">
                        <br> <br>

                        <p>
                            The code is straightforward; we exclude the exact position of our red button.
                        </p>

                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-rendering-3d">
                        <h4>Render 3D</h4>
                        <p>
                            Let's render some 3D geometry.
                            For this, we'll need separate shaders; if you're following the tutorial in order, here they are:
                        </p>
                        <pre class="rounded copy"><code class="language-cpp">
#define VERTEX_SOURCE3D \
"#version 330 core                                                                                                 \n" \
"layout (location = 0) in vec3 aPos;                                                                               \n" \
"layout (location = 1) in vec2 aTexCoord;                                                                          \n" \
"                                                                                                                  \n" \
"out vec2 TexCoord;                                                                                                \n" \
"                                                                                                                  \n" \
"uniform mat4 projection;                                                                                          \n" \
"uniform mat4 view;                                                                                                \n" \
"                                                                                                                  \n" \
"void main()                                                                                                       \n" \
"{                                                                                                                 \n" \
"    gl_Position = projection * view * vec4(aPos, 1.0f);                                                           \n" \
"    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);                                                              \n" \
"}                                                                                                                 \n" \

#define FRAGMENT_SOURCE3D \
"#version 330 core                                                                                                 \n" \
"out vec4 FragColor;                                                                                               \n" \
"                                                                                                                  \n" \
"in vec2 TexCoord;                                                                                                 \n" \
"                                                                                                                  \n" \
"uniform sampler2D texture1;                                                                                       \n" \
"                                                                                                                  \n" \
"void main()                                                                                                       \n" \
"{                                                                                                                 \n" \
"    FragColor = texture(texture1, TexCoord);                                                                      \n" \
"}                                                                                                                 \n" \
                        </code></pre>
                        <br>

                        <p>
                            We'll also create a 3d cube, and a checkerboard texture:
                        </p>

                        <pre class="rounded copy"><code class="language-cpp">
float vertices3d[] = {
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
};

unsigned int VBO3D, VAO3D;
glGenVertexArrays(1, &VAO3D);
glGenBuffers(1, &VBO3D);
glBindVertexArray(VAO3D);
glBindBuffer(GL_ARRAY_BUFFER, VBO3D);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices3d), vertices3d, GL_STATIC_DRAW);
// position attribute
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// texture coord attribute
glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);

unsigned int checkerboard[] = {
    0xFFFFFFFF, 0xFF000000,
    0xFF000000, 0xFFFFFFFF
};

GLuint texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 2, 2, 0, GL_RGBA, GL_UNSIGNED_BYTE, checkerboard);
glGenerateMipmap(GL_TEXTURE_2D);
                        </code></pre>
                        <br>

                        <p>
                            Since we'll be rendering both 3D and 2D, we'll need to make sure GL_DEPTH_TEST is only
                            enabled for the 3D part of our rendering;
                        </p>

                        <pre><code class="language-cpp">
glDisable(GL_DEPTH_TEST);
glUseProgram(program);
glBindVertexArray(VAO);

float projection[16];
vd_fw_u_ortho(0.f, (float)w, (float)h, 0.f, -1.f, 1.f, projection);
glUniformMatrix4fv(glGetUniformLocation(program, "projection"), 1, GL_FALSE, projection);
// ... Rest of 2D rendering code

glEnable(GL_DEPTH_TEST);
// 3D rendering code
                        </code></pre>

                        <p>
                            Before our main loop, we're also going to add some variables for the camera:
                        </p>

                        <pre><code class="language-cpp">
float camera_position[3] = {0.f, 0.f, -2.f};
float camera_yaw   = 0.f;
float camera_pitch = 30.f;
float deg2rad = 3.14159265359f / 180.f;
float camera_speed = 2.f;
                        </code></pre>

                        <p>
                            Now for rendering the cube depending on camera position:
                        </p>

                        <pre><code class="language-cpp">
glEnable(GL_DEPTH_TEST);
float fw = (float)w;
float fh = (float)h;

// Compute forward vector
float camera_forward[3] = {
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_SIN(deg2rad * camera_yaw),
    VD_FW_SIN(deg2rad * camera_pitch),
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_COS(deg2rad * camera_yaw)
};

// Normalize forward vector
float camera_forward_len = VD_FW_SQRT(
    camera_forward[0] * camera_forward[0] +
    camera_forward[1] * camera_forward[1] +
    camera_forward[2] * camera_forward[2]);

camera_forward[0] = camera_forward[0] / camera_forward_len;
camera_forward[1] = camera_forward[1] / camera_forward_len;
camera_forward[2] = camera_forward[2] / camera_forward_len;

float camera_ref_up[3] = {0.f, 1.f, 0.f};

// Compute right vector by taking the cross product of foward x up
float camera_right[3] = {
    camera_forward[1] * camera_ref_up[2] - camera_forward[2] * camera_ref_up[1],
    camera_forward[2] * camera_ref_up[0] - camera_forward[0] * camera_ref_up[2],
    camera_forward[0] * camera_ref_up[1] - camera_forward[1] * camera_ref_up[0],
};

// Normalize right vector
float camera_right_len = VD_FW_SQRT(
    camera_right[0] * camera_right[0] +
    camera_right[1] * camera_right[1] +
    camera_right[2] * camera_right[2]);

camera_right[0] = camera_right[0] / camera_right_len;
camera_right[1] = camera_right[1] / camera_right_len;
camera_right[2] = camera_right[2] / camera_right_len;

glViewport(0, 0, w, h - 30);
glUseProgram(program3d);
glBindVertexArray(VAO3D);

float projection[16] = {0.f};
vd_fw_u_perspective(60.f, fw / fh, 0.1f, 100.0f, projection);

float view[16] = {0.f};
float ctar[3] = {
    camera_position[0] + camera_forward[0],
    camera_position[1] + camera_forward[1],
    camera_position[2] + camera_forward[2]};
float cup[3]  = {0.f, 1.f, 0.f};
vd_fw_u_lookat(camera_position, ctar, cup, view);

glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture);

glUseProgram(program3d);
glUniformMatrix4fv(glGetUniformLocation(program3d, "projection"), 1, GL_FALSE, projection);
glUniformMatrix4fv(glGetUniformLocation(program3d, "view"), 1, GL_FALSE, view);
glUniform1i(glGetUniformLocation(program3d, "texture1"), 0);

glBindVertexArray(VAO3D);

glDrawArrays(GL_TRIANGLES, 0, 36);
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-rendering-cube.gif">
                        <br> <br>

                        <p>
                            And here we have a 3d cube! As you can see, I've already added the movement of the camera
                            for demonstration purposes, but we'll have a look at input in the next section.
                        </p>

                    </section> 
                    <br>

                    <section class="L2 section" id="tutorials-input">
                        <h4>Input</h4> 

                        <p>
                            We've already seen some mouse state handling, bu let's look at the main functions used for
                            input:
                            <ul>
                                <li><code>vd_fw_delta_s</code>, to get delta time since last frame</li>
                                <li><code>vd_fw_get_mouse_state</code>, to read the mouse state</li>
                                <li><code>vd_fw_get_mouse_delta</code>, to read how much the mouse moved since last frame</li>
                                <li><code>vd_fw_get_key_down</code>, to check if a key is currently down</li>
                                <li><code>vd_fw_get_key_pressed</code>, to check if a key was just pressed</li>
                                <li><code>vd_fw_set_mouse_locked</code>, to hide and confine the mouse to the window</li>
                            </ul>
                        </p>

                        <p>
                            So let's add some camera manipulation, we'll start by getting the delta time in seconds:
                        </p>

                        <pre><code class="language-cpp">
float ds = vd_fw_delta_s();
                        </code></pre>

                        <p>
                            It's also common to lock the mouse and hide it, so let's do that as well at the start of the
                            application;
                        </p>

                        <pre><code class="language-cpp">
vd_fw_set_mouse_locked(1);
                        </code></pre>

                        <p>
                            Here's also the snippet for how to move the camera
                        </p>

                        <pre><code class="language-cpp">
// Get key states
float fwdir = (float)(vd_fw_get_key_down('W') - vd_fw_get_key_down('S'));
float rgdir = (float)(vd_fw_get_key_down('A') - vd_fw_get_key_down('D'));
float updir = (float)(vd_fw_get_key_down('Q') - vd_fw_get_key_down('E'));

// Compute overall move direction
float camera_move_dir[3] = {
    fwdir * camera_forward[0] + rgdir * camera_right[0] + updir * camera_ref_up[0],
    fwdir * camera_forward[1] + rgdir * camera_right[1] + updir * camera_ref_up[1],
    fwdir * camera_forward[2] + rgdir * camera_right[2] + updir * camera_ref_up[2],
};

// Normalize move direction, if it's length is not too small (i.e. we're not pressing any keys)
float camera_dir_lensq = 
    camera_move_dir[0] * camera_move_dir[0] +
    camera_move_dir[1] * camera_move_dir[1] +
    camera_move_dir[2] * camera_move_dir[2];

if (camera_dir_lensq > 0.0001f) {
    // 
    float camera_move_dir_len = VD_FW_SQRT(camera_dir_lensq);

    camera_move_dir[0] = camera_move_dir[0] / camera_move_dir_len;
    camera_move_dir[1] = camera_move_dir[1] / camera_move_dir_len;
    camera_move_dir[2] = camera_move_dir[2] / camera_move_dir_len;

    camera_position[0] += camera_move_dir[0] * camera_speed * ds;
    camera_position[1] += camera_move_dir[1] * camera_speed * ds;
    camera_position[2] += camera_move_dir[2] * camera_speed * ds;
}
                        </code></pre>

                        <p>
                            Finally, inside of our rendering loop, we compute the camera's pitch and yaw based on the mouse:
                        </p>

                        <pre><code class="language-cpp">
if (vd_fw_get_mouse_locked()) {
    float mouse_delta_x, mouse_delta_y;
    vd_fw_get_mouse_delta(&mouse_delta_x, &mouse_delta_y);

    camera_yaw   += mouse_delta_x;
    camera_pitch -= mouse_delta_y;
};

if (camera_pitch < -89.9f) camera_pitch = -89.9f;
if (camera_pitch > +89.9f) camera_pitch = +89.9f;

if (camera_yaw > +360.f) camera_yaw -= 360.f;
if (camera_yaw < -360.f) camera_yaw += 360.f;

float camera_forward[3] = {
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_SIN(deg2rad * camera_yaw),
    // ..
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-rendering-camera.gif">
                        <br> <br>

                        <p>
                            Okay, we can move the cube, but we can't really exit the application easily, since the mouse
                            is confined. Let's make 'Shift + F1' unlock the mouse:
                        </p>

                        <pre><code class="language-cpp">
if (vd_fw_get_mouse_locked()) {
    float mouse_delta_x, mouse_delta_y;
    vd_fw_get_mouse_delta(&mouse_delta_x, &mouse_delta_y);

    camera_yaw   += mouse_delta_x;
    camera_pitch -= mouse_delta_y;
};

if (camera_pitch < -89.9f) camera_pitch = -89.9f;
if (camera_pitch > +89.9f) camera_pitch = +89.9f;

if (camera_yaw > +360.f) camera_yaw -= 360.f;
if (camera_yaw < -360.f) camera_yaw += 360.f;

float camera_forward[3] = {
    VD_FW_COS(deg2rad * camera_pitch) * VD_FW_SIN(deg2rad * camera_yaw),
    // ..
                        </code></pre>

                        <img class="rounded img-fluid rmprint" src="/assets/fw/tutorials-rendering-cubeapp.gif">
                        <br> <br>

                        <p>
                            And we finally have, a resizable, draggable window with our own custom button and cube.
                        </p>

                    </section>

                    <!-- Begin API -->
                    <section class="L1 section" id="api-ref">
                        <h4>Reference</h4>
                        <hr>
                        <!-- VD_FW_API int                vd_fw_init(VdFwInitInfo *info); -->
                        <div id="vd_fw_init" class="apiitem function">
                            <span class="item-decl">int vd_fw_init(VdFwInitInfo *info)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Initializes the library. Any call before this is invalid.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>info</td>
                                        <td>Options for the window and OpenGL context. Leave null for default.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!--                                                 VdFwInitInfo -->
                        <div id="VdFwInitInfo" class="L2 apiitem function">
                            <span class="item-decl">VdFwInitInfo</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Info struct passed to <code>vd_fw_init</code>.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>VdFwInitInfo::gl::version</td>
                                        <td>Version of OpenGL to load.</td>
                                    </tr>
                                    <tr><td>VdFwInitInfo::gl::debug_on</td>
                                        <td>Enable <a href="https://www.khronos.org/opengl/wiki/Debugging_Tools#Debug_Output">debugging for OpenGL</a>.</td>
                                    </tr>
                                    <tr><td>VdFwInitInfo::window_options::borderless</td>
                                        <td>Set to 1 to disable window decorations.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>
                        <!--                                                 VdFwInitInfo -->

                        <div id="vd_fw_running" class="apiitem function">
                            <span class="item-decl">int vd_fw_running(void)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    Check if the application is running. Call this every frame.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>Return Value</td>
                                        <td>1 if running, 0 otherwise.</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- VD_FW_API int                vd_fw_swap_buffers(void); -->
                        <div id="vd_fw_init" class="apiitem function">
                            <span class="item-decl">int vd_fw_swap_buffers(void)</span>
                            <div class="apidetails">
                                <p class="item-desc">
                                    End rendering and swap buffers. Call this right at the end of your rendering code.
                                </p>
                                <table class="table">
                                <tbody>
                                    <tr><td>Return Value</td>
                                        <td>(Reserved for future use)</td>
                                    </tr>
                                </tbody>
                                </table>
                            </div>
                        </div>
                    </section>
                    <!--   End API -->

                    <div class="d-flex">
                        <span class="text-muted flex-grow-1 align-self-end">&copy; Michael Dodis, 2025-2026.</span>
                        <button type="button" class="btn ms-2 btn-outline-success" onclick="window.print();">PDF</button>
                        <a download type="button" class="btn ms-2 btn-outline-success" href="https://raw.githubusercontent.com/mdodis/vd-libs/main/vd_fw.h">Download</a>
                    </div>

                </div>

        <footer class="footer mt-auto py-3 bg-dark">
            <div class="container">
            </div>
        </footer>

            </div>
        </div>
        <!--   End Content -->

        <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"> -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
                integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI"
                crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
                integrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
                crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="/auto-toc.js"></script>
        <script src="/index.js"></script>
    </body>
</html>